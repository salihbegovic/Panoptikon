<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Panoptikon 2.7 — Videos & Playlists</title>
  <style>
    body { margin:0; font-family: system-ui, sans-serif; background:#0b0c10; color:#e8ecf1; }
    .wrap { max-width: 1800px; margin: 20px auto; padding: 12px; }
    h1 { font-size: clamp(20px,3.2vw,30px); margin: 0 0 12px; }
    .hint { color:#a7b0bb; font-size:14px; margin-bottom:10px; }
    .controls { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:8px 0; }
    input[type="number"], select, input[type="text"], input[type="password"] {
      padding:6px 8px; border-radius:8px; border:1px solid #2a303d; background:#0f1320; color:#e8ecf1;
    }
    input[type="number"] { width:80px; }
    input[type="text"] { width:260px; }
    input[type="password"] { width:300px; }
    button { cursor:pointer; border:1px solid #2a303d; background:#111827; color:#e8ecf1; padding:8px 12px; border-radius:10px; font-weight:600; }

    /* Make the table/grid fluid */
    table { border-collapse:separate; border-spacing:6px; margin:auto; width:100%; }
    td { background:#0d1117; border:1px solid #1c2230; border-radius:8px; padding:0; vertical-align:top; }

    /* Responsive 16:9 video boxes */
    .video-container {
      position: relative;
      width: 100%;
      padding-top: 56.25%; /* 16:9 */
      overflow: hidden;
      border-radius: 6px;
    }
    .video-container iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
      border-radius: 6px;
    }

    .cell { position:relative; border-radius:8px; }
    .cell.swap-highlight { outline:2px solid #7dd3fc; box-shadow:0 0 0 3px rgba(125,211,252,.25) inset; }
    .cell.swap-pending { outline:2px solid #a78bfa; box-shadow:0 0 0 3px rgba(167,139,250,.25) inset; }

    .error { background:#2b1414; border:1px solid #3b1a1a; color:#ffd5d5; padding:10px; border-radius:10px; white-space:pre-wrap; }

    /* Fullscreen adjustments */
    #gridWrapper:fullscreen { width:100vw; height:100vh; margin:0; }
    #gridWrapper:fullscreen table { width:100%; height:100%; border-spacing:2px; }
    #gridWrapper:fullscreen td { padding:0; }
    #gridWrapper:fullscreen .video-container { padding-top:56.25%; }

    #gridWrapper:-webkit-full-screen { width:100vw; height:100vh; }
    #gridWrapper:-webkit-full-screen table { width:100%; height:100%; border-spacing:2px; }
    #gridWrapper:-webkit-full-screen td { padding:0; }
    #gridWrapper:-webkit-full-screen .video-container { padding-top:56.25%; }

    .badge { font-size:11px; opacity:.8; padding:2px 6px; border:1px solid #2a303d; border-radius:999px; }
    .toggle-on { background:#0b3a2b; border-color:#134e4a; }

    /* Swap-mode UX */
    .swap-mode iframe { pointer-events:none; filter: saturate(0.9) brightness(0.95); }
    .swap-mode .cell { cursor: crosshair; }
    .swap-mode .cell.swap-pending { outline:2px dashed #a78bfa; box-shadow:0 0 0 3px rgba(167,139,250,.25) inset; }

    /* Empty-slot styling (no fixed pixel size to keep responsive) */
    .cell.empty {
      display:flex; align-items:center; justify-content:center;
      color:#6b7280; border:1px dashed #2a303d;
      border-radius:8px; background:repeating-linear-gradient(45deg,#0d1117,#0d1117 8px,#0f1320 8px,#0f1320 16px);
      font-size:12px; letter-spacing:.04em; text-transform:uppercase;
      min-height: 200px;
    }
    #gridWrapper:fullscreen .cell.empty { min-height: unset; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>📺 Panoptikon 2.7 <span class="badge">(Hurensohn Edition)</span></h1>
    <img src="QRCode.png" alt="QR Code" width="200" height="200"><br>
    <a href="https://docs.google.com/spreadsheets/d/1wtC8tG9LB4RhvqWBPHyJdBDbvtlwXkd1IcvXL8AR_yM/edit?usp=sharing" target="_blank">The links are to be put in the google sheet</a>

    <div class="controls">
      <label>Source:
        <select id="sourceSelect" title="Choose data source"></select>
      </label>
      <label>Columns: <input id="cols" type="number" min="1" max="12" value="2"></label>
      <label>Rows: <input id="rows" type="number" min="1" max="12" value="2"></label>
      <label><input type="checkbox" id="forceGrid"> Force grid size</label>
      <label><input type="checkbox" id="allowDuplicates" checked> Allow Duplicates</label>
      <button id="reload">Rebuild Grid</button>
      <button id="fullscreenBtn">Fullscreen</button>
      <button id="resetBtn">Reset Progress</button>
      <button id="swapModeBtn" title="Click to enable swap, then click two videos to swap their positions">Swap Mode</button>
      <!-- Playlist expansion toggle -->
      <button id="expandPlaylistsBtn" title="Toggle whether playlists load as one item or expand into all videos">Playlists: ONE item</button>
    </div>

    <!-- YouTube Search (API-based) -->
    <div class="controls">
      <input id="searchInput" type="text" placeholder="Search YouTube (e.g. ambient music)" />
      <button id="searchFillBtn" title="Fill grid with top results for this query">Search Fill</button>
      <button id="randomFillBtn" title="Fill grid with random results for this query">Random Fill</button>
      <span class="hint">If "Force grid size" is on, search fetches exactly Rows×Columns.</span>
    </div>

    <!-- API key row (stored locally) -->
    <div class="controls">
      <input id="ytApiKey" type="password" placeholder="YouTube Data API key (stored locally)" />
      <button id="saveKeyBtn">Save Key</button>
      <span class="hint" id="keyStatus"></span>
    </div>

    <div id="status" class="hint"></div>
    <div class="hint" id="loadedCount" style="margin-top:4px; opacity:.9;"></div>
    <div id="error" class="error" style="display:none"></div>

    <div id="gridWrapper">
      <table><tbody id="tbody"></tbody></table>
    </div>
  </div>

  <script>
    const SOURCES = [
      { label: "Sheet 1", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=0&single=true&output=csv"},
      { label: "Sheet 2", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=331016320&single=true&output=csv" },
      { label: "Sheet 3", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=181596337&single=true&output=csv" },
      { label: "Sheet 4", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=362795220&single=true&output=csv" },
      { label: "Sheet 5", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=1039723187&single=true&output=csv" }
    ];
    const STORAGE_KEY = "panoptikon_source_index";
    const POS_PREFIX = "panoptikon_time_";
    const KEY_STORE = "panoptikon_yt_api_key";
    const REGION_CODE = "AT";
    const MAX_ITEMS = 200;

    // Persist playlist expansion preference
    const EXPAND_STORE = "panoptikon_expand_playlists"; // "1" | "0"

    function saveTime(key, seconds) {
      try { localStorage.setItem(POS_PREFIX + key, String(Math.floor(seconds))); } catch {}
    }
    function loadTime(key) {
      const v = +localStorage.getItem(POS_PREFIX + key);
      return Number.isFinite(v) && v > 0 ? v : 0;
    }
    function resetProgress() {
      Object.keys(localStorage).forEach(k => {
        if (k.startsWith(POS_PREFIX)) localStorage.removeItem(k);
      });
      init();
    }

    // Parse YouTube values from sheets
    function parseYouTube(x) {
      if (!x) return null;
      x = (""+x).trim();
      if (/^[a-zA-Z0-9_-]{11}$/.test(x)) return { kind:"video", id:x };
      if (!/^https?:\/\//i.test(x)) x = "https://" + x;
      let u; try { u = new URL(x); } catch { return null; }
      const host = u.hostname.replace(/^www\./,"");
      const list = u.searchParams.get("list");

      if (host === "youtu.be") {
        const vid = u.pathname.split("/").filter(Boolean)[0];
        if (list) return { kind:"playlist", id:list };
        if (vid && /^[a-zA-Z0-9_-]{11}$/.test(vid)) return { kind:"video", id:vid };
        return null;
      }
      if (!/youtube\.com$/.test(host)) return null;

      if (list && /^[a-zA-Z0-9_-]{10,}$/.test(list)) return { kind:"playlist", id:list };
      const v = u.searchParams.get("v");
      if (v && /^[a-zA-Z0-9_-]{11}$/.test(v)) return { kind:"video", id:v };
      const m1 = u.pathname.match(/\/shorts\/([a-zA-Z0-9_-]{5,})/);
      if (m1) return { kind:"video", id:m1[1].slice(0,11) };
      const m2 = u.pathname.match(/\/embed\/([a-zA-Z0-9_-]{5,})/);
      if (m2) return { kind:"video", id:m2[1].slice(0,11) };
      const tail = u.pathname.split("/").filter(Boolean).pop();
      if (tail && /^[a-zA-Z0-9_-]{5,}$/.test(tail)) return { kind:"video", id:tail.slice(0,11) };
      return null;
    }

    function embedUrl(item) {
      const params = new URLSearchParams({
        autoplay: "1", mute: "1", loop: "1",
        wmode: "opaque", autohide: "1", enablejsapi: "1",
        start: "0", iv_load_policy: "3", rel: "0", playsinline: "1"
      });
      if (item.kind === "video") {
        params.set("playlist", item.id); // loop same video
        return `https://www.youtube.com/embed/${item.id}?${params.toString()}`;
      } else if (item.kind === "playlist") {
        params.set("listType", "playlist");
        params.set("list", item.id);
        return `https://www.youtube.com/embed?${params.toString()}`;
      }
      return "about:blank";
    }

    async function fetchItems(url) {
      const res = await fetch(url, { credentials: "omit", cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}\n${url}`);
      const text = await res.text();
      if (/ServiceLogin|accounts\.google\.com/i.test(text)) throw new Error("Sheet must be public.");
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const values = lines.map(l => (l.includes(",") || l.includes("\t")) ? l.split(/,|\t/)[0].trim() : l);
      if (values.length && !parseYouTube(values[0])) values.shift();
      let items = values.map(parseYouTube).filter(Boolean);
      if (!document.getElementById("allowDuplicates").checked) {
        const seen = new Set();
        items = items.filter(it => { const key = `${it.kind}:${it.id}`; if (seen.has(key)) return false; seen.add(key); return true; });
      }
      return items.slice(0, MAX_ITEMS);
    }

    // YouTube Iframe API (for progress resume)
    let ytApiReady = false;
    function ensureYouTubeAPI() {
      if (window.YT && YT.Player) { ytApiReady = true; initPlayers(); return; }
      if (document.getElementById("yt-iframe-api")) return;
      const tag = document.createElement("script");
      tag.id = "yt-iframe-api"; tag.src = "https://www.youtube.com/iframe_api";
      document.head.appendChild(tag);
      window.onYouTubeIframeAPIReady = () => { ytApiReady = true; initPlayers(); };
    }
    const playerIntervals = new Map();
    function clearPlayerIntervals() { for (const i of playerIntervals.values()) clearInterval(i); playerIntervals.clear(); }
    function initPlayers() {
      if (!ytApiReady) return;
      const iframes = Array.from(document.querySelectorAll("#tbody iframe[data-progress-key]"));
      iframes.forEach((ifr) => {
        if (ifr.dataset.bound === "1") return;
        const pkey = ifr.dataset.progressKey;
        const player = new YT.Player(ifr.id, {
          events: {
            onReady: (e) => {
              const t = loadTime(pkey);
              if (t > 1) { try { e.target.seekTo(t, true); } catch {} }
              try { e.target.playVideo(); } catch {}
            },
            onStateChange: (e) => {
              try { const cur = e.target.getCurrentTime?.(); if (Number.isFinite(cur)) saveTime(pkey, cur); } catch {}
            }
          }
        });
        const intervalId = setInterval(() => {
          try { const cur = player.getCurrentTime(); if (Number.isFinite(cur)) saveTime(pkey, cur); } catch {}
        }, 3000);
        playerIntervals.set(ifr.id, intervalId);
        ifr.dataset.bound = "1";
      });
    }

    // Forced grid helpers
    function getGridSettings() {
      const cols = Math.max(1, Math.min(12, +document.getElementById("cols").value || 1));
      const forced = !!document.getElementById("forceGrid")?.checked;
      let rows = Math.max(1, Math.min(12, +document.getElementById("rows").value || cols));
      return { cols, rows, forced, slots: cols * rows };
    }

    // >>> Responsive cell with video-container <<<
    function makeCell(item, idx) {
      const td = document.createElement("td");
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.cellIndex = String(idx);

      const container = document.createElement("div");
      container.className = "video-container";

      const ifr = document.createElement("iframe");
      const iframeId = `playeryt_${item.kind}_${(item.id||"")}_${idx+1}`;
      ifr.id = iframeId; ifr.src = embedUrl(item);
      ifr.allow = "autoplay; clipboard-write; encrypted-media; picture-in-picture; accelerometer; gyroscope; fullscreen";
      ifr.setAttribute('allowfullscreen','');
      ifr.setAttribute('webkitallowfullscreen','');
      ifr.setAttribute('mozallowfullscreen','');
      ifr.dataset.progressKey = `${item.kind}:${item.id||idx}`;

      container.appendChild(ifr);
      cell.appendChild(container);
      td.appendChild(cell);
      cell.addEventListener('click', onCellClick);
      return td;
    }

    function makeEmptyCell(idx) {
      const td = document.createElement("td");
      const cell = document.createElement("div");
      cell.className = "cell empty";
      cell.dataset.cellIndex = String(idx);
      cell.textContent = "Empty";
      cell.addEventListener('click', onCellClick);
      td.appendChild(cell);
      return td;
    }

    function buildTable(items, settings) {
      const { cols, rows, forced, slots } = settings;
      const tbody = document.getElementById("tbody");
      clearPlayerIntervals();
      tbody.innerHTML = "";

      let list = items.slice();
      if (forced) list = list.slice(0, slots);

      const rowCount = forced ? rows : Math.max(1, Math.ceil(list.length / cols));
      let i = 0;
      for (let r = 0; r < rowCount; r++) {
        const rowEl = document.createElement("tr");
        tbody.appendChild(rowEl);
        for (let c = 0; c < cols; c++) {
          if (i < list.length) {
            rowEl.appendChild(makeCell(list[i], i));
            i++;
          } else {
            if (forced) rowEl.appendChild(makeEmptyCell(i));
            i++;
          }
        }
      }
      ensureYouTubeAPI();
      requestAnimationFrame(resizeForFullscreen);
    }

    // With responsive CSS, we don't need to size iframes via JS anymore.
    function resizeForFullscreen() {
      /* Intentionally left minimal; CSS handles sizing. */
    }

    function getSelectedSourceIndex() {
      const v = +localStorage.getItem(STORAGE_KEY);
      return Number.isInteger(v) && v >= 0 && v < SOURCES.length ? v : 0;
    }
    function setSelectedSourceIndex(i) { localStorage.setItem(STORAGE_KEY, String(i)); }
    function currentSourceUrl() {
      const sel = document.getElementById("sourceSelect");
      return SOURCES[sel.selectedIndex]?.url || SOURCES[0].url;
    }

    // Playlist expansion preference
    function getExpandPref() { return localStorage.getItem(EXPAND_STORE) === "1"; }
    function setExpandPref(v) { localStorage.setItem(EXPAND_STORE, v ? "1" : "0"); }

    // Fetch all videos in a playlist (for expansion mode)
    async function fetchPlaylistVideos(playlistId, maxTotal = MAX_ITEMS) {
      const key = getApiKey();
      if (!key) throw new Error("Expanding playlists needs a YouTube Data API key. Save one above and try again.");
      const out = [];
      let pageToken = "";
      while (out.length < maxTotal) {
        const url = new URL("https://www.googleapis.com/youtube/v3/playlistItems");
        url.search = new URLSearchParams({
          key,
          part: "contentDetails",
          playlistId,
          maxResults: "50",
          pageToken
        }).toString();
        const r = await fetch(url.toString());
        if (!r.ok) {
          const txt = await r.text();
          throw new Error(`YouTube API error for playlist ${playlistId}: HTTP ${r.status}\n${txt}`);
        }
        const data = await r.json();
        const vids = (data.items || []).map(it => it.contentDetails?.videoId).filter(Boolean);
        out.push(...vids);
        pageToken = data.nextPageToken || "";
        if (!pageToken) break;
      }
      return out.map(id => ({ kind: "video", id }));
    }

    async function expandPlaylistsIfEnabled(items, expand) {
      if (!expand) return items;
      const allowDup = document.getElementById("allowDuplicates").checked;
      const status = document.getElementById("status");
      const error = document.getElementById("error");

      const seen = new Set();
      const push = (arr, it) => {
        if (allowDup) { arr.push(it); return true; }
        const k = `video:${it.id}`;
        if (seen.has(k)) return false;
        seen.add(k); arr.push(it); return true;
      };

      if (!allowDup) {
        items.forEach(it => { if (it.kind === "video") seen.add(`video:${it.id}`); });
      }

      const out = [];
      let playlistsExpanded = 0;
      for (const it of items) {
        if (out.length >= MAX_ITEMS) break;
        if (it.kind === "playlist") {
          try {
            status.textContent = `Expanding playlist ${playlistsExpanded+1}…`;
            const vids = await fetchPlaylistVideos(it.id, MAX_ITEMS);
            for (const v of vids) {
              if (out.length >= MAX_ITEMS) break;
              push(out, v);
            }
            playlistsExpanded++;
          } catch (e) {
            console.warn(e);
            error.style.display = "block";
            error.textContent = (error.textContent ? error.textContent + "\n" : "") + (e.message || String(e));
            out.push(it);
          }
        } else {
          push(out, it);
        }
      }
      status.textContent = `Expanded ${playlistsExpanded} playlist${playlistsExpanded===1?"":"s"} into videos.`;
      return out.slice(0, MAX_ITEMS);
    }

    // Compute an optimal near-square grid (used only when Force grid is OFF)
    function computeOptimalGrid(n) {
      n = Math.max(1, Math.min(144, n)); // cap to 12×12 UI limits
      let best = { cols: 1, rows: n, waste: 0, aspect: Infinity };
      for (let cols = 1; cols <= Math.min(12, n); cols++) {
        const rows = Math.ceil(n / cols);
        if (rows > 12) continue;
        const slots = cols * rows;
        const waste = slots - n;
        const aspect = Math.abs(cols - rows);
        const isBetter =
          waste < best.waste ||
          (waste === best.waste && aspect < best.aspect) ||
          (waste === best.waste && aspect === best.aspect && rows < best.rows);
        if (isBetter) best = { cols, rows, waste, aspect };
      }
      return { cols: best.cols, rows: best.rows };
    }
    function applyGridToInputs(cols, rows) {
      const colsEl = document.getElementById("cols");
      const rowsEl = document.getElementById("rows");
      colsEl.value = String(cols);
      rowsEl.value = String(rows);
    }

    async function init() {
      // hydrate key UI
      const k = localStorage.getItem(KEY_STORE) || "";
      const keyInput = document.getElementById("ytApiKey");
      keyInput.value = k ? "••••••••••••" : "";
      document.getElementById("keyStatus").textContent = k ? "API key saved locally." : "No API key saved yet.";

      // hydrate expand toggle
      expandPlaylists = getExpandPref();
      renderExpandBtn();

      const status = document.getElementById("status");
      const error = document.getElementById("error");
      const loadedCountEl = document.getElementById("loadedCount");
      error.style.display = "none";
      status.textContent = "Loading links…";
      loadedCountEl.textContent = "";

      try {
        let items = await fetchItems(currentSourceUrl());

        // counts before expansion
        const preCounts = items.reduce((acc, it) => { acc[it.kind] = (acc[it.kind]||0)+1; return acc; }, {video:0, playlist:0});

        // Expand playlists if toggle is ON
        if (expandPlaylists) items = await expandPlaylistsIfEnabled(items, true);

        // Auto grid when NOT forced
        const forceGridEl = document.getElementById("forceGrid");
        if (!forceGridEl.checked) {
          const n = items.length;
          const { cols, rows } = computeOptimalGrid(n);
          applyGridToInputs(cols, rows);
        }

        const settings = getGridSettings();
        const display = settings.forced ? items.slice(0, settings.slots) : items;
        const missing = settings.forced ? Math.max(0, settings.slots - display.length) : 0;

        // counts after expansion (what will render)
        const postCounts = display.reduce((acc, it) => { acc[it.kind] = (acc[it.kind]||0)+1; return acc; }, {video:0, playlist:0});

        // Live counter of embeds
        loadedCountEl.textContent = `Loaded embeds: ${display.length} (${expandPlaylists ? "videos expanded from playlists" : "videos & playlists as-is"})`;

        const summary = settings.forced
          ? `Loaded ${display.length}/${settings.slots} slot(s) — ${expandPlaylists
              ? `${postCounts.video} video(s) (expanded from ${preCounts.playlist} playlist${preCounts.playlist===1?"":"s"})`
              : `${preCounts.video} video(s), ${preCounts.playlist} playlist(s)`}.`
          : `Loaded ${display.length} item${display.length===1?"":"s"} — ${expandPlaylists
              ? `${postCounts.video} video(s) (expanded from ${preCounts.playlist} playlist${preCounts.playlist===1?"":"s"})`
              : `${preCounts.video} video(s), ${preCounts.playlist} playlist(s)`}. (Auto grid: ${document.getElementById("cols").value}×${document.getElementById("rows").value})`;

        status.textContent = summary + (missing ? ` (showing ${missing} empty slot${missing===1?"":"s"})` : "");
        buildTable(display, settings);
      } catch (e) {
        status.textContent = "";
        document.getElementById("loadedCount").textContent = "";
        error.textContent = e.message || String(e);
        error.style.display = "block";
        console.error(e);
      }
    }

    (function setupSourceSelect() {
      const sel = document.getElementById("sourceSelect");
      sel.innerHTML = "";
      SOURCES.forEach(s => { const opt = document.createElement("option"); opt.textContent = s.label; sel.appendChild(opt); });
      sel.selectedIndex = getSelectedSourceIndex();
      sel.addEventListener("change", () => { setSelectedSourceIndex(sel.selectedIndex); init(); });
    })();

    document.getElementById("reload").addEventListener("click", init);
    document.getElementById("fullscreenBtn").addEventListener("click", () => {
      const wrapper = document.getElementById("gridWrapper");
      if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        (wrapper.requestFullscreen || wrapper.webkitRequestFullscreen)?.call(wrapper);
      } else {
        (document.exitFullscreen || document.webkitExitFullscreen)?.call(document);
      }
    });
    document.getElementById("resetBtn").addEventListener("click", resetProgress);
    document.addEventListener("fullscreenchange", resizeForFullscreen);
    document.addEventListener("webkitfullscreenchange", resizeForFullscreen);
    window.addEventListener("resize", resizeForFullscreen);

    // Swap Mode (click two cells to swap)
    let swapMode = false;
    let firstCell = null;
    const swapBtn = document.getElementById('swapModeBtn');
    swapBtn.addEventListener('click', () => {
      swapMode = !swapMode;
      swapBtn.classList.toggle('toggle-on', swapMode);
      swapBtn.textContent = swapMode ? 'Swap Mode: ON' : 'Swap Mode';
      document.body.classList.toggle('swap-mode', swapMode);
      clearSwapHighlights(); firstCell = null;
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && swapMode) {
        swapMode = false; document.body.classList.remove('swap-mode');
        swapBtn.classList.remove('toggle-on'); swapBtn.textContent = 'Swap Mode';
        clearSwapHighlights(); firstCell = null;
      }
    });
    function clearSwapHighlights() {
      document.querySelectorAll('.cell').forEach(c => c.classList.remove('swap-highlight','swap-pending'));
    }
    function onCellClick(e) {
      if (!swapMode) return;
      const cell = e.currentTarget;
      if (!firstCell) { firstCell = cell; clearSwapHighlights(); cell.classList.add('swap-pending'); return; }
      if (cell === firstCell) { firstCell.classList.remove('swap-pending'); firstCell = null; return; }
      swapCellContents(firstCell, cell);
      firstCell.classList.remove('swap-pending'); cell.classList.add('swap-highlight');
      setTimeout(() => { cell.classList.remove('swap-highlight'); }, 400);
      firstCell = null; requestAnimationFrame(() => { ensureYouTubeAPI(); resizeForFullscreen(); });
    }
    function swapCellContents(cellA, cellB) {
      const tempA = document.createElement('div');
      while (cellA.firstChild) tempA.appendChild(cellA.firstChild);
      const tempB = document.createElement('div');
      while (cellB.firstChild) tempB.appendChild(cellB.firstChild);
      while (tempB.firstChild) cellA.appendChild(tempB.firstChild);
      while (tempA.firstChild) cellB.appendChild(tempA.firstChild);
      const hasIframeA = !!cellA.querySelector('iframe');
      const hasIframeB = !!cellB.querySelector('iframe');
      cellA.classList.toggle('empty', !hasIframeA);
      cellB.classList.toggle('empty', !hasIframeB);
    }

    // API key handling
    document.getElementById("saveKeyBtn").addEventListener("click", () => {
      const input = document.getElementById("ytApiKey");
      const v = input.value.trim();
      if (!v) { localStorage.removeItem(KEY_STORE); document.getElementById("keyStatus").textContent = "Cleared API key."; return; }
      localStorage.setItem(KEY_STORE, v);
      input.value = "••••••••••••";
      document.getElementById("keyStatus").textContent = "API key saved locally.";
    });

    function getApiKey() {
      const v = localStorage.getItem(KEY_STORE) || "AIzaSyCqWACV98qEukeDyNF6wk7HID_m2XXu8Sc";
      return v;
    }

    // YouTube Search (Data API v3, embeddable only)
    async function searchYouTubeEmbeddable(query, needed, randomize=false) {
      const key = getApiKey();
      if (!key) throw new Error("Please provide a YouTube Data API key to use search.");
      const allowDup = document.getElementById("allowDuplicates").checked;

      const results = [];
      let pageToken = "";
      while (results.length < needed) {
        const batch = Math.min(50, needed - results.length);
        const url = new URL("https://www.googleapis.com/youtube/v3/search");
        url.search = new URLSearchParams({
          key,
          part: "snippet",
          q: query,
          maxResults: String(batch),
          type: "video",
          videoEmbeddable: "true",
          regionCode: REGION_CODE,
          safeSearch: "none",
          order: "relevance",
          pageToken
        }).toString();

        const r = await fetch(url.toString());
        if (!r.ok) {
          const text = await r.text();
          throw new Error(`YouTube API error: HTTP ${r.status}\n${text}`);
        }
        const data = await r.json();
        const vids = (data.items || []).map(it => it.id?.videoId).filter(Boolean);

        if (!allowDup) {
          const existing = new Set(results);
          vids.forEach(v => { if (!existing.has(v)) results.push(v); });
        } else {
          results.push(...vids);
        }

        pageToken = data.nextPageToken || "";
        if (!pageToken && results.length < needed) break;
      }

      let picked = results.slice(0);
      if (randomize) {
        for (let i=picked.length-1;i>0;i--) { const j=Math.floor(Math.random()*(i+1)); [picked[i],picked[j]]=[picked[j],picked[i]]; }
      }
      if (picked.length < needed && allowDup && picked.length > 0) {
        while (picked.length < needed) picked.push(picked[picked.length % results.length]);
      }
      return picked.slice(0, needed).map(id => ({ kind:"video", id }));
    }

    async function doSearchFill(randomize=false) {
      const q = (document.getElementById("searchInput").value || "").trim();
      const settings = getGridSettings();
      const total = settings.forced ? settings.slots : settings.cols * settings.cols;
      const status = document.getElementById("status");
      const error = document.getElementById("error");
      error.style.display = "none";

      if (!q) { error.textContent = "Please enter a search query."; error.style.display = "block"; return; }

      status.textContent = `Searching YouTube for “${q}”… (need ${total} embeddable video${total===1?'':'s'})`;
      try {
        const items = await searchYouTubeEmbeddable(q, total, randomize);
        if (!items.length) {
          error.textContent = "No embeddable videos found for that query.";
          error.style.display = "block"; status.textContent = ""; return;
        }
        const missing = Math.max(0, total - items.length);
        status.textContent = missing
          ? `Found ${items.length}/${total} video(s) for “${q}”.` 
          : `Loaded ${items.length} videos for “${q}”.`;
        buildTable(items, settings);
      } catch (e) {
        error.textContent = e.message || String(e);
        error.style.display = "block";
        status.textContent = "";
        console.error(e);
      }
    }

    document.getElementById("searchFillBtn").addEventListener("click", () => { doSearchFill(false); });
    document.getElementById("randomFillBtn").addEventListener("click", () => { doSearchFill(true); });

    // Playlist toggle wiring
    let expandPlaylists = getExpandPref();
    const expandBtn = document.getElementById("expandPlaylistsBtn");
    function renderExpandBtn() {
      expandBtn.classList.toggle("toggle-on", expandPlaylists);
      expandBtn.textContent = expandPlaylists ? "Playlists: ALL videos" : "Playlists: ONE item";
    }
    expandBtn.addEventListener("click", () => {
      expandPlaylists = !expandPlaylists;
      setExpandPref(expandPlaylists);
      renderExpandBtn();
      init();
    });

    // Boot
    init();
  </script>
</body>
</html>

