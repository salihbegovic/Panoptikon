<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Telegram Live Video Wall</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    color: #fff;
    font-family: sans-serif;
    height: 100%;
    overflow: hidden;
  }
  header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(0,0,0,0.7);
    padding: 6px 12px;
    position: relative;
    z-index: 10;
  }
  h1 {
    font-size: 16px;
    margin: 0;
    opacity: 0.8;
  }
  button {
    background: #111;
    color: #fff;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 4px 10px;
    cursor: pointer;
    font-weight: 600;
  }
  input {
    background: #111;
    color: #fff;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 2px 6px;
  }
  #wall {
    display: grid;
    grid-template-columns: repeat(5, 1fr); /* default 5 columns */
    grid-auto-rows: 1fr;
    gap: 6px;
    width: 100%;
    height: calc(100% - 36px);
    padding: 6px;
    box-sizing: border-box;
    overflow: hidden;
  }
  .tile {
    position: relative;
    background: #111;
    border-radius: 8px;
    overflow: hidden;
    aspect-ratio: 16 / 9;
  }
  iframe {
    width: 100%;
    height: 100%;
    border: 0;
  }
  .timestamp {
    position: absolute;
    bottom: 4px;
    right: 8px;
    font-size: 10px;
    background: rgba(0,0,0,0.6);
    padding: 2px 6px;
    border-radius: 4px;
  }

  :fullscreen #wall,
  :-webkit-full-screen #wall {
    height: 100%;
    padding: 8px;
  }
  :fullscreen header,
  :-webkit-full-screen header {
    display: none;
  }

  /* smaller QR code in lower right */
  #qrOverlay {
    position: fixed;
    bottom: 16px;
    right: 16px;
    width: 80px;
    height: auto;
    opacity: 0.9;
    z-index: 9999;
    display: none;
    pointer-events: none;
  }
  :fullscreen #qrOverlay,
  :-webkit-full-screen #qrOverlay {
    display: block;
  }
</style>
</head>
<body>
<header>
  <h1>Telegram Live Wall</h1>
  <div>
    <label style="margin-right:8px;">
      Columns:
      <input id="cols" type="number" min="1" max="10" value="5" style="width:50px;">
    </label>
    <label style="margin-right:8px;">
      Max Videos:
      <input id="maxVideos" type="number" min="1" max="200" value="25" style="width:60px;">
    </label>
    <button id="applyGrid">Apply</button>
    <button id="fullscreenBtn">Fullscreen</button>
  </div>
</header>

<img id="qrOverlay" src="QRCodeTelegram.png" alt="QR Code">

<div id="wall"></div>

<script>
const FILE_URL = "youtube_links.txt";   // Telethon output file
const POLL_INTERVAL = 3000;             // ms between checks
let MAX_VIDEOS = 25;                    // default, can change in UI

const wall = document.getElementById("wall");
let known = new Set();

/**
 * Build proper embed URL:
 * - Single video: loops that video.
 * - Playlist: auto plays through playlist & loops.
 */
function ytEmbed(item) {
  if (item.kind === "playlist") {
    const p = new URLSearchParams({
      autoplay: 1,
      mute: 1,
      loop: 1,
      listType: "playlist",
      list: item.id,
      rel: 0,
      controls: 1,
      playsinline: 1
    });
    return "https://www.youtube.com/embed?" + p.toString();
  }

  // default: single video, loop by using playlist param = same id
  const p = new URLSearchParams({
    autoplay: 1,
    mute: 1,
    loop: 1,
    playlist: item.id,
    rel: 0,
    controls: 1,
    playsinline: 1
  });
  return `https://www.youtube.com/embed/${item.id}?` + p.toString();
}

/**
 * Parse a line into either:
 * - { kind: "video", id: "VIDEO_ID" }
 * - { kind: "playlist", id: "PLAYLIST_ID" }
 */
function parseLine(line) {
  line = (line || "").trim();
  if (!line) return null;

  // raw video id
  if (/^[\w-]{11}$/.test(line)) {
    return { kind: "video", id: line };
  }

  // ensure URL-y
  if (!/^https?:\/\//i.test(line)) {
    line = "https://" + line;
  }

  try {
    const u = new URL(line);
    const host = u.hostname.replace(/^www\./, "");

    const list = u.searchParams.get("list");
    const v = u.searchParams.get("v");

    // playlist URL
    if (list && /^[\w-]+$/.test(list)) {
      return { kind: "playlist", id: list };
    }

    // standard watch URL with v=
    if (v && /^[\w-]{11}$/.test(v)) {
      return { kind: "video", id: v };
    }

    // youtu.be short links
    if (host === "youtu.be") {
      const m = u.pathname.match(/\/([\w-]{11})$/);
      if (m) return { kind: "video", id: m[1] };
    }
  } catch (e) {
    // fall through to null
  }

  return null;
}

async function poll() {
  try {
    const res = await fetch(FILE_URL + "?_=" + Date.now(), { cache: "no-store" });
    if (!res.ok) return;

    const text = await res.text();
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

    for (const line of lines) {
      const item = parseLine(line);
      if (!item) continue;

      const key = item.kind + ":" + item.id;
      if (known.has(key)) continue;
      known.add(key);

      addVideo(item);
      maintainLimit();
    }
  } catch (e) {
    console.error("poll error", e);
  } finally {
    setTimeout(poll, POLL_INTERVAL);
  }
}

function addVideo(item) {
  const div = document.createElement("div");
  div.className = "tile";

  const ifr = document.createElement("iframe");
  ifr.src = ytEmbed(item);
  ifr.allow = "autoplay; encrypted-media; picture-in-picture";

  const ts = document.createElement("div");
  ts.className = "timestamp";
  ts.textContent = new Date().toLocaleTimeString();

  div.append(ifr, ts);
  wall.insertBefore(div, wall.firstChild);
}

function maintainLimit() {
  while (wall.children.length > MAX_VIDEOS) {
    const last = wall.lastElementChild;
    if (last) wall.removeChild(last);
  }
}

document.getElementById("applyGrid").onclick = () => {
  const cols = Math.max(1, Math.min(10, +document.getElementById("cols").value || 5));
  wall.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

  const newMax = Math.max(1, Math.min(200, +document.getElementById("maxVideos").value || 25));
  if (newMax !== MAX_VIDEOS) {
    MAX_VIDEOS = newMax;
    maintainLimit();
  }
};

document.getElementById("fullscreenBtn").onclick = () => {
  if (!document.fullscreenElement && !document.webkitFullscreenElement) {
    (document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen).call(document.documentElement);
  } else {
    (document.exitFullscreen || document.webkitExitFullscreen).call(document);
  }
};

poll();
</script>
</body>
</html>
