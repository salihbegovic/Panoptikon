<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Panoptikon 3.0 â€” Videos & Playlists</title>
  <style>
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", sans-serif; background:#0b0c10; color:#e8ecf1; }
    .wrap { max-width: 1800px; margin: 20px auto; padding: 12px; }
    h1 { font-size: clamp(20px,3.2vw,30px); margin: 0 0 12px; display:flex; align-items:center; gap:10px; }
    .hint { color:#a7b0bb; font-size:14px; margin-bottom:10px; }
    .controls { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:8px 0; }
    input[type="number"], select, input[type="text"], input[type="password"] {
      padding:6px 8px; border-radius:8px; border:1px solid #2a303d; background:#0f1320; color:#e8ecf1;
    }
    input[type="number"] { width:80px; }
    input[type="text"] { width:260px; }
    input[type="password"] { width:300px; }
    button { cursor:pointer; border:1px solid #2a303d; background:#111827; color:#e8ecf1; padding:8px 12px; border-radius:10px; font-weight:600; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .badge { font-size:11px; opacity:.8; padding:2px 6px; border:1px solid #2a303d; border-radius:999px; }
    .toggle-on { background:#0b3a2b; border-color:#134e4a; }

    /* Sources preview gallery */
    .sources { display:grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap:12px; margin:14px 0 6px; }
    .source-card {
      background:#0d1117; border:1px solid #1c2230; border-radius:12px; padding:10px; display:flex; flex-direction:column; gap:8px;
      transition: transform .1s ease, box-shadow .1s ease, border-color .1s ease;
      cursor:pointer; min-height: 180px;
    }
    .source-card:hover { transform: translateY(-1px); box-shadow:0 8px 24px rgba(0,0,0,.25); border-color:#2a303d; }
    .source-head { display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .source-title { font-weight:700; font-size:14px; letter-spacing:.02em; }
    .counts { font-size:12px; color:#9aa5b1; display:flex; gap:8px; }

    /* Auto-grid preview (scaled) */
    .preview-shell {
      position: relative;
      border: 1px solid #1c2230;
      border-radius: 10px;
      background: #0b0f18;
      padding: 6px;
      overflow: hidden;
      height: 240px;
    }
    .preview-scale {
      position: absolute;
      top: 6px; left: 6px;
      transform-origin: top left;
    }
    .preview-grid {
      display: grid;
      gap: 6px;
      background: transparent;
    }
    .preview-tile {
      position: relative;
      width: 160px;
      padding-top: 56.25%;          /* 16:9 */
      border-radius: 8px;
      overflow: hidden;
      background:#0f1320;
      border:1px solid #1c2230;
      display:flex; align-items:center; justify-content:center;
      color:#94a3b8; font-size:11px; text-transform:uppercase; letter-spacing:.06em;
    }
    .preview-tile img {
      position:absolute; inset:0; width:100%; height:100%; object-fit:cover;
    }
    .active-source { outline:2px solid #7dd3fc; box-shadow:0 0 0 3px rgba(125,211,252,.25) inset; }

    /* Grid/table for main embeds */
    table { border-collapse:separate; border-spacing:6px; margin:auto; width:100%; table-layout: fixed; } /* fixed widths */
    td { background:#0d1117; border:1px solid #1c2230; border-radius:8px; padding:0; vertical-align:top; }

    /* Main embeds: padding-top set via JS */
    .video-container { position: relative; width: 100%; padding-top: 56.25%; overflow: hidden; border-radius: 6px; transition: padding-top .12s ease; }
    .video-container iframe { position: absolute; inset: 0; width: 100%; height: 100%; border: 0; display: block; border-radius: 6px; }

    .cell { position:relative; border-radius:8px; }
    .cell.swap-highlight { outline:2px solid #7dd3fc; box-shadow:0 0 0 3px rgba(125,211,252,.25) inset; }
    .cell.swap-pending { outline:2px solid #a78bfa; box-shadow:0 0 0 3px rgba(167,139,250,.25) inset; }

    .error { background:#2b1414; border:1px solid #3b1a1a; color:#ffd5d5; padding:10px; border-radius:10px; white-space:pre-wrap; }

    /* Fullscreen */
    #gridWrapper:fullscreen { width:100vw; height:100vh; margin:0; }
    #gridWrapper:fullscreen table { width:100%; height:100%; border-spacing:2px; }
    #gridWrapper:fullscreen td { padding:0; }
    #gridWrapper:-webkit-full-screen { width:100vw; height:100vh; }
    #gridWrapper:-webkit-full-screen table { width:100%; height:100%; border-spacing:2px; }
    #gridWrapper:-webkit-full-screen td { padding:0; }

    /* Swap-mode UX */
    .swap-mode iframe { pointer-events:none; filter: saturate(0.9) brightness(0.95); }
    .swap-mode .cell { cursor: crosshair; }
    .swap-mode .cell.swap-pending { outline:2px dashed #a78bfa; box-shadow:0 0 0 3px rgba(167,139,250,.25) inset; }

    /* Empty-slot styling */
    .cell.empty {
      display:flex; align-items:center; justify-content:center;
      color:#6b7280; border:1px dashed #2a303d;
      border-radius:8px; background:repeating-linear-gradient(45deg,#0d1117,#0d1117 8px,#0f1320 8px,#0f1320 16px);
      font-size:12px; letter-spacing:.04em; text-transform:uppercase;
      min-height: 200px;
    }
    #gridWrapper:fullscreen .cell.empty { min-height: unset; }

    /* Small helpers */
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .spacer { flex:1; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ðŸ“º Panoptikon 3.0 <span class="badge">Ich ficke deine Mutter</span></h1>
    <img src="QRCode.png" alt="QR Code" width="200" height="200"><br>
    <a href="https://docs.google.com/spreadsheets/d/1wtC8tG9LB4RhvqWBPHyJdBDbvtlwXkd1IcvXL8AR_yM/edit?usp=sharing" target="_blank">The links are to be put in the google sheet</a>

    <!-- Sources preview gallery -->
    <div class="row" style="margin-top:10px;">
      <div class="hint">Everything old - once was young. Everything young - someday dies.</div>
      <div class="spacer"></div>
      <span class="hint" id="previewStatus"></span>
    </div>
    <div id="sourcesPreview" class="sources"></div>

    <div class="controls">
      <label>Columns: <input id="cols" type="number" min="1" max="12" value="2"></label>
      <label>Rows: <input id="rows" type="number" min="1" max="12" value="2"></label>
      <label><input type="checkbox" id="forceGrid"> Force grid size</label>
      <label><input type="checkbox" id="allowDuplicates" checked> Allow Duplicates</label>
      <button id="reload">Rebuild Grid</button>
      <button id="fullscreenBtn">Fullscreen</button>
      <button id="aspectModeBtn" title="Toggle tile aspect behavior">Aspect: 16:9</button>
      <button id="resetBtn">Reset Progress</button>
      <button id="swapModeBtn" title="Click to enable swap, then click two videos to swap their positions">Swap Mode</button>
      <button id="saveLayoutBtn" title="Save current order">Save Layout</button>
      <button id="clearLayoutBtn" title="Clear saved order">Clear Layout</button>
      <button id="expandPlaylistsBtn" title="Toggle whether playlists load as one item or expand into all videos">Playlists: ONE item</button>
    </div>

    <!-- YouTube Search (API-based) -->
    <div class="controls">
      <input id="searchInput" type="text" placeholder="Search YouTube (e.g. ambient music)" />
      <button id="searchFillBtn" title="Fill grid with top results for this query">Search Fill</button>
      <button id="randomFillBtn" title="Fill grid with random results for this query">Random Fill</button>
      <span class="hint">If "Force grid size" is on, search fetches exactly RowsÃ—Columns.</span>
    </div>

    <!-- API key row (stored locally) -->
    <div class="controls">
      <input id="ytApiKey" type="password" placeholder="YouTube Data API key (stored locally)" />
      <button id="saveKeyBtn">Save Key</button>
      <span class="hint" id="keyStatus"></span>
    </div>

    <div id="status" class="hint"></div>
    <div class="hint" id="loadedCount" style="margin-top:4px; opacity:.9;"></div>
    <div id="error" class="error" style="display:none"></div>

    <div id="gridWrapper">
      <table><tbody id="tbody"></tbody></table>
    </div>
  </div>

  <script>
    /***********************
     * Config
     ***********************/
    const SOURCES = [
      { label: "Sheet 1", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=0&single=true&output=csv"},
      { label: "Sheet 2", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=331016320&single=true&output=csv" },
      { label: "Sheet 3", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=181596337&single=true&output=csv" },
      { label: "Sheet 4", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=362795220&single=true&output=csv" },
      { label: "Sheet 5", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=1039723187&single=true&output=csv" },
      { label: "Telegram Chat", url: "youtube_links.txt" }
    ];
    const STORAGE_SELECTED = "panoptikon_selected_index"; // active source index
    const POS_PREFIX = "panoptikon_time_";
    const KEY_STORE = "panoptikon_yt_api_key";
    const REGION_CODE = "AT";
    const MAX_ITEMS = 200;
    const EXPAND_STORE = "panoptikon_expand_playlists"; // "1" | "0"

    // NEW: layout persistence
    const LAYOUT_STORE_PREFIX = "panoptikon_layout_";
    function layoutKey() {
      const label = SOURCES[getSelectedIndex()]?.label || "Sheet";
      return `${LAYOUT_STORE_PREFIX}${label}:${expandPlaylists ? "expanded" : "one"}`;
    }
    function getItemKey(it) { return `${it.kind}:${it.id||""}`; }
    function saveCurrentLayout() {
      const order = Array.from(document.querySelectorAll("#tbody .cell iframe"))
        .map(ifr => ifr?.dataset?.progressKey)
        .filter(Boolean);
      try { localStorage.setItem(layoutKey(), JSON.stringify(order)); } catch {}
      document.getElementById("status").textContent = "Layout saved.";
    }
    function loadSavedLayout() {
      try {
        const raw = localStorage.getItem(layoutKey());
        return raw ? JSON.parse(raw) : null;
      } catch { return null; }
    }
    function clearSavedLayout() {
      localStorage.removeItem(layoutKey());
    }

    /***********************
     * Aspect mode (default: FIXED 16:9)
     ***********************/
    const ASPECT_MODE_STORE = "panoptikon_aspect_mode"; // "auto" | "fixed"
    function getAspectMode() {
      const v = localStorage.getItem(ASPECT_MODE_STORE);
      // Default to FIXED if nothing stored
      return v === "auto" ? "auto" : "fixed";
    }
    function setAspectMode(v) {
      localStorage.setItem(ASPECT_MODE_STORE, v === "auto" ? "auto" : "fixed");
    }
    function renderAspectBtn() {
      const btn = document.getElementById("aspectModeBtn");
      if (!btn) return;
      const mode = getAspectMode();
      btn.textContent = mode === "auto" ? "Aspect: AUTO-FIT" : "Aspect: 16:9";
      btn.classList.toggle("toggle-on", mode === "auto");
    }

    /***********************
     * Utilities
     ***********************/
    function saveTime(key, seconds) {
      try { localStorage.setItem(POS_PREFIX + key, String(Math.floor(seconds))); } catch {}
    }
    function loadTime(key) {
      const v = +localStorage.getItem(POS_PREFIX + key);
      return Number.isFinite(v) && v > 0 ? v : 0;
    }
    function resetProgress() {
      Object.keys(localStorage).forEach(k => {
        if (k.startsWith(POS_PREFIX)) localStorage.removeItem(k);
      });
      // also clear saved layout for current context
      clearSavedLayout();
      init(); // rebuild grid & previews
    }

    // Parse YouTube values from sheets
    function parseYouTube(x) {
      if (!x) return null;
      x = (""+x).trim();
      if (/^[a-zA-Z0-9_-]{11}$/.test(x)) return { kind:"video", id:x };
      if (!/^https?:\/\//i.test(x)) x = "https://" + x;
      let u; try { u = new URL(x); } catch { return null; }
      const host = u.hostname.replace(/^www\./,"");
      const list = u.searchParams.get("list");

      if (host === "youtu.be") {
        const vid = u.pathname.split("/").filter(Boolean)[0];
        if (list) return { kind:"playlist", id:list };
        if (vid && /^[a-zA-Z0-9_-]{11}$/.test(vid)) return { kind:"video", id:vid };
        return null;
      }
      if (!/youtube\.com$/.test(host)) return null;

      if (list && /^[a-zA-Z0-9_-]{10,}$/.test(list)) return { kind:"playlist", id:list };
      const v = u.searchParams.get("v");
      if (v && /^[a-zA-Z0-9_-]{11}$/.test(v)) return { kind:"video", id:v };
      const m1 = u.pathname.match(/\/shorts\/([a-zA-Z0-9_-]{5,})/);
      if (m1) return { kind:"video", id:m1[1].slice(0,11) };
      const m2 = u.pathname.match(/\/embed\/([a-zA-Z0-9_-]{5,})/);
      if (m2) return { kind:"video", id:m2[1].slice(0,11) };
      const tail = u.pathname.split("/").filter(Boolean).pop();
      if (tail && /^[a-zA-Z0-9_-]{5,}$/.test(tail)) return { kind:"video", id:tail.slice(0,11) };
      return null;
    }

    function embedUrl(item) {
      const params = new URLSearchParams({
        autoplay: "1", mute: "1", loop: "1",
        wmode: "opaque", autohide: "1", enablejsapi: "1",
        start: "0", iv_load_policy: "3", rel: "0", playsinline: "1"
      });
      if (item.kind === "video") {
        params.set("playlist", item.id); // loop same video
        return `https://www.youtube.com/embed/${item.id}?${params.toString()}`;
      } else if (item.kind === "playlist") {
        params.set("listType", "playlist");
        params.set("list", item.id);
        return `https://www.youtube.com/embed?${params.toString()}`;
      }
      return "about:blank";
    }

    // YouTube Iframe API for progress resume
    let ytApiReady = false;
    function ensureYouTubeAPI() {
      if (window.YT && YT.Player) { ytApiReady = true; initPlayers(); return; }
      if (document.getElementById("yt-iframe-api")) return;
      const tag = document.createElement("script");
      tag.id = "yt-iframe-api"; tag.src = "https://www.youtube.com/iframe_api";
      document.head.appendChild(tag);
      window.onYouTubeIframeAPIReady = () => { ytApiReady = true; initPlayers(); };
    }
    const playerIntervals = new Map();
    function clearPlayerIntervals() { for (const i of playerIntervals.values()) clearInterval(i); playerIntervals.clear(); }
    function initPlayers() {
      if (!ytApiReady) return;
      const iframes = Array.from(document.querySelectorAll("#tbody iframe[data-progress-key]"));
      iframes.forEach((ifr) => {
        if (ifr.dataset.bound === "1") return;
        const pkey = ifr.dataset.progressKey;
        const player = new YT.Player(ifr.id, {
          events: {
            onReady: (e) => {
              const t = loadTime(pkey);
              if (t > 1) { try { e.target.seekTo(t, true); } catch {} }
              try { e.target.playVideo(); } catch {}
            },
            onStateChange: (e) => {
              try { const cur = e.target.getCurrentTime?.(); if (Number.isFinite(cur)) saveTime(pkey, cur); } catch {}
            }
          }
        });
        const intervalId = setInterval(() => {
          try { const cur = player.getCurrentTime(); if (Number.isFinite(cur)) saveTime(pkey, cur); } catch {}
        }, 3000);
        playerIntervals.set(ifr.id, intervalId);
        ifr.dataset.bound = "1";
      });
    }

    /***********************
     * Grid helpers
     ***********************/
    function getGridSettings() {
      const cols = Math.max(1, Math.min(12, +document.getElementById("cols").value || 1));
      const forced = !!document.getElementById("forceGrid")?.checked;
      let rows = Math.max(1, Math.min(12, +document.getElementById("rows").value || cols));
      return { cols, rows, forced, slots: cols * rows };
    }

    function makeCell(item, idx) {
      const td = document.createElement("td");
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.cellIndex = String(idx);

      const container = document.createElement("div");
      container.className = "video-container";

      const ifr = document.createElement("iframe");
      const iframeId = `playeryt_${item.kind}_${(item.id||"")}_${idx+1}`;
      ifr.id = iframeId; ifr.src = embedUrl(item);
      ifr.allow = "autoplay; clipboard-write; encrypted-media; picture-in-picture; accelerometer; gyroscope; fullscreen";
      ifr.setAttribute('allowfullscreen','');
      ifr.setAttribute('webkitallowfullscreen','');
      ifr.setAttribute('mozallowfullscreen','');
      ifr.dataset.progressKey = `${item.kind}:${item.id||idx}`;

      container.appendChild(ifr);
      cell.appendChild(container);
      td.appendChild(cell);
      cell.addEventListener('click', onCellClick);
      return td;
    }

    function makeEmptyCell(idx) {
      const td = document.createElement("td");
      const cell = document.createElement("div");
      cell.className = "cell empty";
      cell.dataset.cellIndex = String(idx);
      cell.textContent = "Empty";
      cell.addEventListener('click', onCellClick);
      td.appendChild(cell);
      return td;
    }

    function buildTable(items, settings) {
      const { cols, rows, forced, slots } = settings;
      const tbody = document.getElementById("tbody");
      clearPlayerIntervals();
      tbody.innerHTML = "";

      let list = items.slice();
      if (forced) list = list.slice(0, slots);

      const rowCount = forced ? rows : Math.max(1, Math.ceil(list.length / cols));
      let i = 0;
      for (let r = 0; r < rowCount; r++) {
        const rowEl = document.createElement("tr");
        tbody.appendChild(rowEl);
        for (let c = 0; c < cols; c++) {
          if (i < list.length) {
            rowEl.appendChild(makeCell(list[i], i));
            i++;
          } else {
            if (forced) rowEl.appendChild(makeEmptyCell(i));
            i++;
          }
        }
      }
      ensureYouTubeAPI();
      requestAnimationFrame(resizeGrid);
    }

    /**
     * Responsive tile aspect based on mode.
     * - Fixed (default): 16:9
     * - Auto-fit: adapt to available W/H per cell
     * Also sets #gridWrapper height to fill remaining viewport when not fullscreen.
     */
    function resizeGrid() {
      const wrapper = document.getElementById("gridWrapper");
      const isFS = document.fullscreenElement === wrapper || document.webkitFullscreenElement === wrapper;

      // When not fullscreen, stretch wrapper to fill remaining viewport height under the controls.
      if (!isFS) {
        const top = wrapper.getBoundingClientRect().top;
        const targetH = Math.max(220, window.innerHeight - top - 16);
        wrapper.style.height = `${Math.floor(targetH)}px`;
      }

      const { cols, rows } = getGridSettings();
      const spacing = isFS ? 2 : 6; // matches CSS table border-spacing we use in FS vs windowed
      const rect = wrapper.getBoundingClientRect();
      const availW = Math.max(0, rect.width  - spacing * (cols + 1));
      const availH = Math.max(0, rect.height - spacing * (rows + 1));
      if (availW <= 0 || availH <= 0) return;

      const containers = wrapper.querySelectorAll(".video-container");

      // Mode: fixed (16:9) or auto-fit
      if (getAspectMode() === "fixed") {
        containers.forEach(c => { c.style.paddingTop = "56.25%"; });
        return;
      }

      // AUTO-FIT (adaptive per screen ratio)
      const cellW = availW / cols;
      const cellH = availH / rows;
      const pct = Math.max(20, Math.min(150, (cellH / cellW) * 100)); // clamp extremes
      containers.forEach(c => { c.style.paddingTop = pct + "%"; });
    }

    /***********************
     * Search helpers
     ***********************/
    function getApiKey() {
      const v = localStorage.getItem(KEY_STORE) || "AIzaSyCqWACV98qEukeDyNF6wk7HID_m2XXu8Sc";
      return v;
    }

    async function searchYouTubeEmbeddable(query, needed, randomize=false) {
      const key = getApiKey();
      if (!key) throw new Error("Please provide a YouTube Data API key to use search.");
      const allowDup = document.getElementById("allowDuplicates").checked;

      const results = [];
      let pageToken = "";
      while (results.length < needed) {
        const batch = Math.min(50, needed - results.length);
        const url = new URL("https://www.googleapis.com/youtube/v3/search");
        url.search = new URLSearchParams({
          key,
          part: "snippet",
          q: query,
          maxResults: String(batch),
          type: "video",
          videoEmbeddable: "true",
          regionCode: REGION_CODE,
          safeSearch: "none",
          order: "relevance",
          pageToken
        }).toString();

        const r = await fetch(url.toString());
        if (!r.ok) {
          const text = await r.text();
          throw new Error(`YouTube API error: HTTP ${r.status}\n${text}`);
        }
        const data = await r.json();
        const vids = (data.items || []).map(it => it.id?.videoId).filter(Boolean);

        if (!allowDup) {
          const existing = new Set(results);
          vids.forEach(v => { if (!existing.has(v)) results.push(v); });
        } else {
          results.push(...vids);
        }

        pageToken = data.nextPageToken || "";
        if (!pageToken && results.length < needed) break;
      }

      let picked = results.slice(0);
      if (randomize) {
        for (let i=picked.length-1;i>0;i--) { const j=Math.floor(Math.random()*(i+1)); [picked[i],picked[j]]=[picked[j],picked[i]]; }
      }
      if (picked.length < needed && allowDup && picked.length > 0) {
        while (picked.length < needed) picked.push(picked[picked.length % results.length]);
      }
      return picked.slice(0, needed).map(id => ({ kind:"video", id }));
    }

    async function doSearchFill(randomize=false) {
      const q = (document.getElementById("searchInput").value || "").trim();
      const settings = getGridSettings();
      const total = settings.forced ? settings.slots : settings.cols * settings.cols;
      const status = document.getElementById("status");
      const error = document.getElementById("error");
      error.style.display = "none";

      if (!q) { error.textContent = "Please enter a search query."; error.style.display = "block"; return; }

      status.textContent = `Searching YouTube for â€œ${q}â€â€¦ (need ${total} embeddable video${total===1?'':'s'})`;
      try {
        const items = await searchYouTubeEmbeddable(q, total, randomize);
        if (!items.length) {
          error.textContent = "No embeddable videos found for that query.";
          error.style.display = "block"; status.textContent = ""; return;
        }
        const missing = Math.max(0, total - items.length);
        status.textContent = missing
          ? `Found ${items.length}/${total} video(s) for â€œ${q}â€.`
          : `Loaded ${items.length} videos for â€œ${q}â€.`;
        buildTable(items, settings);
        updateLoadedCounts(items);
      } catch (e) {
        error.textContent = e.message || String(e);
        error.style.display = "block";
        status.textContent = "";
        console.error(e);
      }
    }

    document.getElementById("searchFillBtn").addEventListener("click", () => { doSearchFill(false); });
    document.getElementById("randomFillBtn").addEventListener("click", () => { doSearchFill(true); });

    /***********************
     * Playlist expansion
     ***********************/
    function getExpandPref() { return localStorage.getItem(EXPAND_STORE) === "1"; }
    function setExpandPref(v) { localStorage.setItem(EXPAND_STORE, v ? "1" : "0"); }
    let expandPlaylists = getExpandPref();
    const expandBtn = document.getElementById("expandPlaylistsBtn");
    function renderExpandBtn() {
      expandBtn.classList.toggle("toggle-on", expandPlaylists);
      expandBtn.textContent = expandPlaylists ? "Playlists: ALL videos" : "Playlists: ONE item";
    }
    expandBtn.addEventListener("click", () => {
      expandPlaylists = !expandPlaylists;
      setExpandPref(expandPlaylists);
      renderExpandBtn();
      // Rebuild main grid with current selection
      loadSelectedIntoGrid(getSelectedIndex());
    });
    renderExpandBtn();

    async function fetchPlaylistVideos(playlistId, maxTotal = MAX_ITEMS) {
      const key = getApiKey();
      if (!key) throw new Error("Expanding playlists needs a YouTube Data API key. Save one above and try again.");
      const out = [];
      let pageToken = "";
      while (out.length < maxTotal) {
        const url = new URL("https://www.googleapis.com/youtube/v3/playlistItems");
        url.search = new URLSearchParams({
          key,
          part: "contentDetails",
          playlistId,
          maxResults: "50",
          pageToken
        }).toString();
        const r = await fetch(url.toString());
        if (!r.ok) {
          const txt = await r.text();
          throw new Error(`YouTube API error for playlist ${playlistId}: HTTP ${r.status}\n${txt}`);
        }
        const data = await r.json();
        const vids = (data.items || []).map(it => it.contentDetails?.videoId).filter(Boolean);
        out.push(...vids);
        pageToken = data.nextPageToken || "";
        if (!pageToken) break;
      }
      return out.map(id => ({ kind: "video", id }));
    }

    async function expandPlaylistsIfEnabled(items, expand) {
      if (!expand) return items;
      const allowDup = document.getElementById("allowDuplicates").checked;
      const status = document.getElementById("status");
      const error = document.getElementById("error");

      const seen = new Set();
      const push = (arr, it) => {
        if (allowDup) { arr.push(it); return true; }
        const k = `video:${it.id}`;
        if (seen.has(k)) return false;
        seen.add(k); arr.push(it); return true;
      };

      if (!allowDup) {
        items.forEach(it => { if (it.kind === "video") seen.add(`video:${it.id}`); });
      }

      const out = [];
      let playlistsExpanded = 0;
      for (const it of items) {
        if (out.length >= MAX_ITEMS) break;
        if (it.kind === "playlist") {
          try {
            status.textContent = `Expanding playlist ${playlistsExpanded+1}â€¦`;
            const vids = await fetchPlaylistVideos(it.id, MAX_ITEMS);
            for (const v of vids) {
              if (out.length >= MAX_ITEMS) break;
              push(out, {kind:"video", id:v});
            }
            playlistsExpanded++;
          } catch (e) {
            console.warn(e);
            error.style.display = "block";
            error.textContent = (error.textContent ? error.textContent + "\n" : "") + (e.message || String(e));
            out.push(it);
          }
        } else {
          push(out, it);
        }
      }
      status.textContent = `Expanded ${playlistsExpanded} playlist${playlistsExpanded===1?"":"s"} into videos.`;
      return out.slice(0, MAX_ITEMS);
    }

    /***********************
     * Auto-grid previews + selection
     ***********************/
    const cache = new Map(); // label -> {items, counts, thumbs}
    function getSelectedIndex() {
      let v = +localStorage.getItem(STORAGE_SELECTED);
      if (!Number.isInteger(v) || v < 0 || v >= SOURCES.length) v = 0; // default to first sheet
      return v;
    }
    function setSelectedIndex(i) {
      const clamped = Math.max(0, Math.min(SOURCES.length - 1, i|0));
      localStorage.setItem(STORAGE_SELECTED, String(clamped));
    }

    function itemCounts(items) {
      return items.reduce((acc, it) => { acc[it.kind] = (acc[it.kind]||0)+1; return acc; }, {});
    }
    function takeVideoThumbs(items, limit=MAX_ITEMS) {
      const ids = [];
      for (const it of items) {
        if (it.kind === "video" && /^[a-zA-Z0-9_-]{11}$/.test(it.id)) {
          ids.push(it.id);
        }
      }
      return ids.slice(0, limit);
    }
    function ytThumbUrl(id) { return `https://i.ytimg.com/vi/${id}/mqdefault.jpg`; }

    // Cache for playlist thumbnails
    const playlistThumbCache = new Map();
    async function fetchPlaylistThumbUrl(playlistId) {
      if (playlistThumbCache.has(playlistId)) return playlistThumbCache.get(playlistId);
      const key = getApiKey();
      if (!key) return null;
      try {
        const url = new URL("https://www.googleapis.com/youtube/v3/playlists");
        url.search = new URLSearchParams({ key, part: "snippet", id: playlistId }).toString();
        const r = await fetch(url.toString());
        if (!r.ok) return null;
        const data = await r.json();
        const t = data.items?.[0]?.snippet?.thumbnails || {};
        const thumb = t.medium?.url || t.standard?.url || t.high?.url || t.default?.url || null;
        if (thumb) playlistThumbCache.set(playlistId, thumb);
        return thumb;
      } catch { return null; }
    }

    async function loadAllSources() {
      const previewStatus = document.getElementById("previewStatus");
      previewStatus.textContent = "Loading sheetsâ€¦";
      const tasks = SOURCES.map(async (src) => {
        const items = await fetchItems(src.url);
        cache.set(src.label, {
          items,
          counts: itemCounts(items),
          thumbs: takeVideoThumbs(items)
        });
      });
      await Promise.all(tasks);

      buildSourcesPreview();
      previewStatus.textContent = `Loaded ${SOURCES.length} sheet(s).`;
    }

    function computeOptimalGrid(n) {
      n = Math.max(1, Math.min(144, n)); // cap to 12Ã—12 UI limits
      let best = { cols: 1, rows: n, waste: 0, aspect: Infinity };
      for (let cols = 1; cols <= Math.min(12, n); cols++) {
        const rows = Math.ceil(n / cols);
        if (rows > 12) continue;
        const slots = cols * rows;
        const waste = slots - n;
        const aspect = Math.abs(cols - rows);
        const isBetter =
          waste < best.waste ||
          (waste === best.waste && aspect < best.aspect) ||
          (waste === best.waste && aspect === best.aspect && rows < best.rows);
        if (isBetter) best = { cols, rows, waste, aspect };
      }
      return { cols: best.cols, rows: best.rows, slots: best.cols * best.rows };
    }

    // Previews are ALWAYS auto-grid now
    function previewAutoShape(itemsLen) {
      return computeOptimalGrid(itemsLen || 1);
    }

    function buildSourcesPreview() {
      const wrap = document.getElementById("sourcesPreview");
      wrap.innerHTML = "";
      const selectedIdx = getSelectedIndex();

      SOURCES.forEach((src, idx) => {
        const data = cache.get(src.label);
        const card = document.createElement("div");
        card.className = "source-card";
        if (idx === selectedIdx) {
          card.classList.add("active-source");
        }

        const head = document.createElement("div");
        head.className = "source-head";
        const title = document.createElement("div");
        title.className = "source-title";
        title.textContent = src.label + " (Auto)";
        const counts = document.createElement("div");
        counts.className = "counts";
        const v = data?.counts?.video || 0;
        const p = data?.counts?.playlist || 0;
        counts.textContent = `${v} video${v===1?"":"s"}${p?` Â· ${p} playlist${p===1?"":"s"}`:""}`;
        head.appendChild(title);
        head.appendChild(counts);

        // Auto-grid preview (scaled miniature)
        const shell = document.createElement("div");
        shell.className = "preview-shell";
        const scaleWrap = document.createElement("div");
        scaleWrap.className = "preview-scale";

        const items = data?.items || [];
        const totalItems = items.length;
        const shape = previewAutoShape(totalItems);

        const grid = document.createElement("div");
        grid.className = "preview-grid";

        // Natural sizes used for scaling: tile width=160px, gap=6px (matching CSS)
        const TILE_W = 160, GAP = 6, TILE_H = Math.round(TILE_W * 9/16);
        const naturalW = shape.cols * TILE_W + (shape.cols - 1) * GAP;
        const naturalH = shape.rows * TILE_H + (shape.rows - 1) * GAP;
        grid.style.gridTemplateColumns = `repeat(${shape.cols}, ${TILE_W}px)`;

        // Fill tiles: thumbnail for videos, fetched thumbnail for playlists, placeholder otherwise
        const totalSlots = shape.slots;
        for (let i = 0; i < totalSlots; i++) {
          const t = document.createElement("div");
          t.className = "preview-tile";
          const item = items[i];

          if (item && item.kind === "video" && /^[a-zA-Z0-9_-]{11}$/.test(item.id)) {
            const img = document.createElement("img");
            img.loading = "lazy";
            img.decoding = "async";
            img.src = ytThumbUrl(item.id);
            img.alt = "Video";
            t.appendChild(img);
          } else if (item && item.kind === "playlist") {
            t.textContent = "â€”";
            fetchPlaylistThumbUrl(item.id).then((url) => {
              if (!url) return;
              if (!t.isConnected) return;
              t.textContent = "";
              const img = document.createElement("img");
              img.loading = "lazy";
              img.decoding = "async";
              img.src = url;
              img.alt = "Playlist";
              t.appendChild(img);
            }).catch(() => {});
          } else {
            t.textContent = "â€”";
          }
          grid.appendChild(t);
        }

        // Mount and scale to fit card
        scaleWrap.appendChild(grid);
        shell.appendChild(scaleWrap);

        // After in DOM, compute scale
        queueMicrotask(() => {
          const cardWidth = card.clientWidth - 20; // padding approx
          const maxHeight = 240; // shell height
          const scale = Math.min(cardWidth / naturalW, maxHeight / naturalH, 1);
          scaleWrap.style.transform = `scale(${Number.isFinite(scale) && scale > 0 ? scale : 1})`;
        });

        card.appendChild(head);
        card.appendChild(shell);

        card.addEventListener("click", () => {
          setSelectedIndex(idx);
          Array.from(document.querySelectorAll(".source-card")).forEach(c => c.classList.remove("active-source"));
          card.classList.add("active-source");
          loadSelectedIntoGrid(idx);
        });

        wrap.appendChild(card);
      });
    }

    function getCurrentItemsForIndex(idx) {
      const label = SOURCES[idx]?.label;
      return cache.get(label)?.items || [];
    }

    function applyGridToInputs(cols, rows) {
      const colsEl = document.getElementById("cols");
      const rowsEl = document.getElementById("rows");
      colsEl.value = String(cols);
      rowsEl.value = String(rows);
    }

    async function loadSelectedIntoGrid(idx) {
      const error = document.getElementById("error");
      const status = document.getElementById("status");
      const loadedCountEl = document.getElementById("loadedCount");
      error.style.display = "none";
      status.textContent = "Preparing gridâ€¦";
      loadedCountEl.textContent = "";

      try {
        let items = getCurrentItemsForIndex(idx).slice(0, MAX_ITEMS);

        // Expand playlists if toggle is ON
        if (expandPlaylists) items = await expandPlaylistsIfEnabled(items, true);

        // Apply saved layout (if any) BEFORE auto/force sizing
        const savedOrder = loadSavedLayout();
        if (Array.isArray(savedOrder) && savedOrder.length) {
          const byKey = new Map(items.map(it => [getItemKey(it), it]));
          const picked = [];
          const seen = new Set();
          // First: items that exist in saved order
          for (const k of savedOrder) {
            const it = byKey.get(k);
            if (it && !seen.has(k)) { picked.push(it); seen.add(k); }
          }
          // Then: any remaining items not in the saved order
          for (const it of items) {
            const k = getItemKey(it);
            if (!seen.has(k)) { picked.push(it); seen.add(k); }
          }
          items = picked;
        }

        // Auto grid when NOT forced
        const forceGridEl = document.getElementById("forceGrid");
        if (!forceGridEl.checked) {
          const n = items.length || 1;
          const { cols, rows } = computeOptimalGrid(n);
          applyGridToInputs(cols, rows);
        }

        const settings = getGridSettings();
        const display = settings.forced ? items.slice(0, settings.slots) : items;
        const missing = settings.forced ? Math.max(0, settings.slots - display.length) : 0;

        const label = SOURCES[idx]?.label || "Sheet";
        document.getElementById("loadedCount").textContent =
          `Loaded embeds: ${display.length} from ${label}${expandPlaylists ? " (playlists expanded)" : ""}`;

        const summary = settings.forced
          ? `Loaded ${display.length}/${settings.slots} slot(s) from ${label}.`
          : `Loaded ${display.length} item${display.length===1?"":"s"} from ${label}. (Auto grid: ${document.getElementById("cols").value}Ã—${document.getElementById("rows").value})`;

        status.textContent = summary + (missing ? ` (showing ${missing} empty slot${missing===1?"":"s"})` : "");
        buildTable(display, settings);
      } catch (e) {
        status.textContent = "";
        document.getElementById("loadedCount").textContent = "";
        error.textContent = e.message || String(e);
        error.style.display = "block";
        console.error(e);
      }
    }

    function updateLoadedCounts(displayItems) {
      const loadedCountEl = document.getElementById("loadedCount");
      loadedCountEl.textContent = `Loaded embeds: ${displayItems.length}`;
    }

    /***********************
     * Swap mode
     ***********************/
    let swapMode = false;
    let firstCell = null;
    const swapBtn = document.getElementById('swapModeBtn');
    swapBtn.addEventListener('click', () => {
      swapMode = !swapMode;
      swapBtn.classList.toggle('toggle-on', swapMode);
      swapBtn.textContent = swapMode ? 'Swap Mode: ON' : 'Swap Mode';
      document.body.classList.toggle('swap-mode', swapMode);
      clearSwapHighlights(); firstCell = null;
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && swapMode) {
        swapMode = false; document.body.classList.remove('swap-mode');
        swapBtn.classList.remove('toggle-on'); swapBtn.textContent = 'Swap Mode';
        clearSwapHighlights(); firstCell = null;
      }
    });
    function clearSwapHighlights() {
      document.querySelectorAll('.cell').forEach(c => c.classList.remove('swap-highlight','swap-pending'));
    }
    function onCellClick(e) {
      if (!swapMode) return;
      const cell = e.currentTarget;
      if (!firstCell) { firstCell = cell; clearSwapHighlights(); cell.classList.add('swap-pending'); return; }
      if (cell === firstCell) { firstCell.classList.remove('swap-pending'); firstCell = null; return; }
      swapCellContents(firstCell, cell);
      firstCell.classList.remove('swap-pending'); cell.classList.add('swap-highlight');
      setTimeout(() => { cell.classList.remove('swap-highlight'); }, 400);
      firstCell = null; requestAnimationFrame(() => { ensureYouTubeAPI(); resizeGrid(); });
      // Auto-save new order after each completed swap
      saveCurrentLayout();
    }
    function swapCellContents(cellA, cellB) {
      const tempA = document.createElement('div');
      while (cellA.firstChild) tempA.appendChild(cellA.firstChild);
      const tempB = document.createElement('div');
      while (cellB.firstChild) tempB.appendChild(cellB.firstChild);
      while (tempB.firstChild) cellA.appendChild(tempB.firstChild);
      while (tempA.firstChild) cellB.appendChild(tempA.firstChild);
      const hasIframeA = !!cellA.querySelector('iframe');
      const hasIframeB = !!cellB.querySelector('iframe');
      cellA.classList.toggle('empty', !hasIframeA);
      cellB.classList.toggle('empty', !hasIframeB);
    }

    /***********************
     * Wiring + Boot
     ***********************/
    document.getElementById("reload").addEventListener("click", () => {
      loadSelectedIntoGrid(getSelectedIndex());
    });
    document.getElementById("fullscreenBtn").addEventListener("click", () => {
      const wrapper = document.getElementById("gridWrapper");
      if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        (wrapper.requestFullscreen || wrapper.webkitRequestFullscreen)?.call(wrapper);
      } else {
        (document.exitFullscreen || document.webkitExitFullscreen)?.call(document);
      }
    });

    // Aspect mode toggle
    const aspectBtn = document.getElementById("aspectModeBtn");
    aspectBtn.addEventListener("click", () => {
      const next = getAspectMode() === "auto" ? "fixed" : "auto";
      setAspectMode(next);
      renderAspectBtn();
      resizeGrid(); // reflow immediately
    });

    document.getElementById("resetBtn").addEventListener("click", resetProgress);

    // Layout buttons
    document.getElementById("saveLayoutBtn").addEventListener("click", saveCurrentLayout);
    document.getElementById("clearLayoutBtn").addEventListener("click", () => {
      clearSavedLayout();
      document.getElementById("status").textContent = "Saved layout cleared.";
    });

    // Resize handlers
    document.addEventListener("fullscreenchange", resizeGrid);
    document.addEventListener("webkitfullscreenchange", resizeGrid);
    window.addEventListener("resize", () => {
      // Rescale previews on resize
      buildSourcesPreview();
      // Keep tiles fitting on resize
      resizeGrid();
    });

    // API key handling
    document.getElementById("saveKeyBtn").addEventListener("click", () => {
      const input = document.getElementById("ytApiKey");
      const v = input.value.trim();
      if (!v) { localStorage.removeItem(KEY_STORE); document.getElementById("keyStatus").textContent = "Cleared API key."; return; }
      localStorage.setItem(KEY_STORE, v);
      input.value = "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢";
      document.getElementById("keyStatus").textContent = "API key saved locally.";
    });

    // Boot
    async function init() {
      // hydrate key label
      const k = localStorage.getItem(KEY_STORE) || "";
      const keyInput = document.getElementById("ytApiKey");
      keyInput.value = k ? "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢" : "";
      document.getElementById("keyStatus").textContent = k ? "API key saved locally." : "No API key saved yet.";

      try {
        await loadAllSources();
      } catch (e) {
        const error = document.getElementById("error");
        error.textContent = e.message || String(e);
        error.style.display = "block";
      }

      // Load previously selected, default to first sheet
      const selected = getSelectedIndex();
      setSelectedIndex(selected);
      loadSelectedIntoGrid(selected);

      // Render aspect button to reflect stored/default mode
      renderAspectBtn();

      // First layout pass
      requestAnimationFrame(resizeGrid);
    }

    // Lightweight fetch of sheet items
    async function fetchItems(url) {
      const res = await fetch(url, { credentials: "omit", cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}\n${url}`);
      const text = await res.text();
      if (/ServiceLogin|accounts\.google\.com/i.test(text)) throw new Error("Sheet must be public.");
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const values = lines.map(l => (l.includes(",") || l.includes("\t")) ? l.split(/,|\t/)[0].trim() : l);
      if (values.length && !parseYouTube(values[0])) values.shift(); // drop header if present
      return values.map(parseYouTube).filter(Boolean).slice(0, MAX_ITEMS);
    }

    init();
  </script>
</body>
</html>
