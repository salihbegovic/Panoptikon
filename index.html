<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Panoptikon 2.6 â€” Videos & Playlists (Hurensohn Edition)</title>
  <style>
    body { margin:0; font-family: system-ui, sans-serif; background:#0b0c10; color:#e8ecf1; }
    .wrap { max-width: 1800px; margin: 20px auto; padding: 12px; }
    h1 { font-size: clamp(20px,3.2vw,30px); margin: 0 0 12px; }
    .hint { color:#a7b0bb; font-size:14px; margin-bottom:10px; }
    .controls { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:8px 0; }
    input[type="number"], select, input[type="text"], input[type="password"] {
      padding:6px 8px; border-radius:8px; border:1px solid #2a303d; background:#0f1320; color:#e8ecf1;
    }
    input[type="number"] { width:80px; }
    input[type="text"] { width:260px; }
    input[type="password"] { width:300px; }
    button { cursor:pointer; border:1px solid #2a303d; background:#111827; color:#e8ecf1; padding:8px 12px; border-radius:10px; font-weight:600; }
    table { border-collapse:separate; border-spacing:6px; margin:auto; width:auto; }
    td { background:#0d1117; border:1px solid #1c2230; border-radius:8px; padding:0; }
    iframe { display:block; border:0; border-radius:6px; width:560px; height:315px; }
    .cell { position:relative; border-radius:8px; }
    .cell.swap-highlight { outline:2px solid #7dd3fc; box-shadow:0 0 0 3px rgba(125,211,252,.25) inset; }
    .cell.swap-pending { outline:2px solid #a78bfa; box-shadow:0 0 0 3px rgba(167,139,250,.25) inset; }
    .error { background:#2b1414; border:1px solid #3b1a1a; color:#ffd5d5; padding:10px; border-radius:10px; white-space:pre-wrap; }
    #gridWrapper:fullscreen { width:100vw; height:100vh; margin:0; }
    #gridWrapper:fullscreen table { width:100%; height:100%; border-spacing:2px; }
    #gridWrapper:fullscreen td { padding:0; }
    #gridWrapper:fullscreen iframe { width:100%; height:100%; }
    #gridWrapper:-webkit-full-screen { width:100vw; height:100vh; }
    #gridWrapper:-webkit-full-screen table { width:100%; height:100%; border-spacing:2px; }
    #gridWrapper:-webkit-full-screen td { padding:0; }
    #gridWrapper:-webkit-full-screen iframe { width:100%; height:100%; }
    .badge { font-size:11px; opacity:.8; padding:2px 6px; border:1px solid #2a303d; border-radius:999px; }
    .toggle-on { background:#0b3a2b; border-color:#134e4a; }
    .swap-mode iframe { pointer-events:none; filter: saturate(0.9) brightness(0.95); }
    .swap-mode .cell { cursor: crosshair; }
    .swap-mode .cell.swap-pending { outline:2px dashed #a78bfa; box-shadow:0 0 0 3px rgba(167,139,250,.25) inset; }

    .cell.empty {
      min-width: 560px; min-height: 315px;
      display:flex; align-items:center; justify-content:center;
      color:#6b7280; border:1px dashed #2a303d;
      border-radius:8px; background:repeating-linear-gradient(45deg,#0d1117,#0d1117 8px,#0f1320 8px,#0f1320 16px);
      font-size:12px; letter-spacing:.04em; text-transform:uppercase;
    }
    #gridWrapper:fullscreen .cell.empty { min-width:unset; min-height:unset; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ðŸ“º Panoptikon 2.6 <span class="badge">(Hurensohn Edition)</span></h1>
    <img src="QRCode.png" alt="QR Code" width="200" height="200"><br>
    <a href="https://docs.google.com/spreadsheets/d/1wtC8tG9LB4RhvqWBPHyJdBDbvtlwXkd1IcvXL8AR_yM/edit?usp=sharing" target="_blank">The links are to be put in the google sheet</a>

    <div class="controls">
      <label>Source:
        <select id="sourceSelect" title="Choose data source"></select>
      </label>
      <label>Columns: <input id="cols" type="number" min="1" max="12" value="2"></label>
      <label>Rows: <input id="rows" type="number" min="1" max="12" value="2"></label>
      <label><input type="checkbox" id="forceGrid"> Force grid size</label>
      <label><input type="checkbox" id="allowDuplicates" checked> Allow Duplicates</label>
      <button id="reload">Rebuild Grid</button>
      <button id="fullscreenBtn">Fullscreen</button>
      <button id="resetBtn">Reset Progress</button>
      <button id="swapModeBtn" title="Click to enable swap, then click two videos to swap their positions">Swap Mode</button>
    </div>

    <div class="controls">
      <input id="searchInput" type="text" placeholder="Search YouTube (e.g. ambient music)" />
      <button id="searchFillBtn" title="Fill grid with top results for this query">Search Fill</button>
      <button id="randomFillBtn" title="Fill grid with random results for this query">Random Fill</button>
      <span class="hint">If "Force grid size" is on, search fetches exactly RowsÃ—Columns.</span>
    </div>

    <div class="controls">
      <input id="ytApiKey" type="password" placeholder="YouTube Data API key (stored locally)" />
      <button id="saveKeyBtn">Save Key</button>
      <span class="hint" id="keyStatus"></span>
    </div>

    <div id="status" class="hint"></div>
    <div id="error" class="error" style="display:none"></div>

    <div id="gridWrapper">
      <table><tbody id="tbody"></tbody></table>
    </div>
  </div>

  <script>
    const SOURCES = [
      { label: "Sheet 1", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=0&single=true&output=csv"},
      { label: "Sheet 2", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=331016320&single=true&output=csv" },
      { label: "Sheet 3", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=181596337&single=true&output=csv" },
      { label: "Sheet 4", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=362795220&single=true&output=csv" },
      { label: "Sheet 5", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=1039723187&single=true&output=csv" }
    ];
    const STORAGE_KEY = "panoptikon_source_index";
    const POS_PREFIX = "panoptikon_time_";
    const KEY_STORE = "panoptikon_yt_api_key";
    const REGION_CODE = "AT";
    const MAX_ITEMS = 200;

    function saveTime(key, seconds) {
      try { localStorage.setItem(POS_PREFIX + key, String(Math.floor(seconds))); } catch {}
    }
    function loadTime(key) {
      const v = +localStorage.getItem(POS_PREFIX + key);
      return Number.isFinite(v) && v > 0 ? v : 0;
    }
    function resetProgress() {
      Object.keys(localStorage).forEach(k => {
        if (k.startsWith(POS_PREFIX)) localStorage.removeItem(k);
      });
      init();
    }

    // â€”â€”â€” Parse YouTube values from sheets
    function parseYouTube(x) {
      if (!x) return null;
      x = (""+x).trim();
      if (/^[a-zA-Z0-9_-]{11}$/.test(x)) return { kind:"video", id:x };
      if (!/^https?:\/\//i.test(x)) x = "https://" + x;
      let u; try { u = new URL(x); } catch { return null; }
      const host = u.hostname.replace(/^www\./,"");
      const list = u.searchParams.get("list");

      if (host === "youtu.be") {
        const vid = u.pathname.split("/").filter(Boolean)[0];
        if (list) return { kind:"playlist", id:list };
        if (vid && /^[a-zA-Z0-9_-]{11}$/.test(vid)) return { kind:"video", id:vid };
        return null;
      }

      if (!/youtube\.com$/.test(host)) return null;

      if (list && /^[a-zA-Z0-9_-]{10,}$/.test(list)) return { kind:"playlist", id:list };
      const v = u.searchParams.get("v");
      if (v && /^[a-zA-Z0-9_-]{11}$/.test(v)) return { kind:"video", id:v };
      const m1 = u.pathname.match(/\/shorts\/([a-zA-Z0-9_-]{5,})/);
      if (m1) return { kind:"video", id:m1[1].slice(0,11) };
      const m2 = u.pathname.match(/\/embed\/([a-zA-Z0-9_-]{5,})/);
      if (m2) return { kind:"video", id:m2[1].slice(0,11) };
      const tail = u.pathname.split("/").filter(Boolean).pop();
      if (tail && /^[a-zA-Z0-9_-]{5,}$/.test(tail)) return { kind:"video", id:tail.slice(0,11) };
      return null;
    }

    function embedUrl(item) {
      const params = new URLSearchParams({
        autoplay: "1", mute: "1", loop: "1",
        wmode: "opaque", autohide: "1", enablejsapi: "1",
        start: "0", iv_load_policy: "3", rel: "0", playsinline: "1"
      });
      if (item.kind === "video") {
        params.set("playlist", item.id); // loop same video
        return `https://www.youtube.com/embed/${item.id}?${params.toString()}`;
      } else if (item.kind === "playlist") {
        params.set("listType", "playlist");
        params.set("list", item.id);
        return `https://www.youtube.com/embed?${params.toString()}`;
      }
      return "about:blank";
    }

    async function fetchItems(url) {
      const res = await fetch(url, { credentials: "omit", cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}\n${url}`);
      const text = await res.text();
      if (/ServiceLogin|accounts\.google\.com/i.test(text)) throw new Error("Sheet must be public.");
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const values = lines.map(l => (l.includes(",") || l.includes("\t")) ? l.split(/,|\t/)[0].trim() : l);
      if (values.length && !parseYouTube(values[0])) values.shift();
      let items = values.map(parseYouTube).filter(Boolean);

      // de-dup (kind:id) if not allowing duplicates
      if (!document.getElementById("allowDuplicates").checked) {
        const seen = new Set();
        items = items.filter(it => {
          const key = `${it.kind}:${it.id}`;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
      }
      return items.slice(0, MAX_ITEMS);
    }

    // â€”â€”â€” YouTube Iframe API for progress resume
    let ytApiReady = false;
    function ensureYouTubeAPI() {
      if (window.YT && YT.Player) { ytApiReady = true; initPlayers(); return; }
      if (document.getElementById("yt-iframe-api")) return;
      const tag = document.createElement("script");
      tag.id = "yt-iframe-api"; tag.src = "https://www.youtube.com/iframe_api";
      document.head.appendChild(tag);
      window.onYouTubeIframeAPIReady = () => { ytApiReady = true; initPlayers(); };
    }
    const playerIntervals = new Map();
    function clearPlayerIntervals() { for (const i of playerIntervals.values()) clearInterval(i); playerIntervals.clear(); }
    function initPlayers() {
      if (!ytApiReady) return;
      const iframes = Array.from(document.querySelectorAll("#tbody iframe[data-progress-key]"));
      iframes.forEach((ifr) => {
        if (ifr.dataset.bound === "1") return;
        const pkey = ifr.dataset.progressKey;
        const player = new YT.Player(ifr.id, {
          events: {
            onReady: (e) => {
              const t = loadTime(pkey);
              if (t > 1) { try { e.target.seekTo(t, true); } catch {} }
              try { e.target.playVideo(); } catch {}
            },
            onStateChange: (e) => {
              try { const cur = e.target.getCurrentTime?.(); if (Number.isFinite(cur)) saveTime(pkey, cur); } catch {}
            }
          }
        });
        const intervalId = setInterval(() => {
          try { const cur = player.getCurrentTime(); if (Number.isFinite(cur)) saveTime(pkey, cur); } catch {}
        }, 3000);
        playerIntervals.set(ifr.id, intervalId);
        ifr.dataset.bound = "1";
      });
    }

    // â€”â€”â€” Forced grid helpers
    function getGridSettings() {
      const cols = Math.max(1, Math.min(12, +document.getElementById("cols").value || 1));
      const forced = !!document.getElementById("forceGrid")?.checked;
      let rows = Math.max(1, Math.min(12, +document.getElementById("rows").value || cols));
      return { cols, rows, forced, slots: cols * rows };
    }

    function makeCell(item, idx) {
      const td = document.createElement("td");
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.cellIndex = String(idx);
      const ifr = document.createElement("iframe");
      const iframeId = `playeryt_${item.kind}_${(item.id||"")}_${idx+1}`;
      ifr.id = iframeId; ifr.src = embedUrl(item);
      ifr.allow = "autoplay; clipboard-write; encrypted-media; picture-in-picture; accelerometer; gyroscope; fullscreen";
      ifr.setAttribute('allowfullscreen',''); ifr.setAttribute('webkitallowfullscreen',''); ifr.setAttribute('mozallowfullscreen','');
      ifr.dataset.progressKey = `${item.kind}:${item.id||idx}`;
      cell.appendChild(ifr);
      td.appendChild(cell);
      cell.addEventListener('click', onCellClick);
      return td;
    }

    function makeEmptyCell(idx) {
      const td = document.createElement("td");
      const cell = document.createElement("div");
      cell.className = "cell empty";
      cell.dataset.cellIndex = String(idx);
      cell.textContent = "Empty";
      cell.addEventListener('click', onCellClick);
      td.appendChild(cell);
      return td;
    }

    function buildTable(items, settings) {
      const { cols, rows, forced, slots } = settings;
      const tbody = document.getElementById("tbody");
      clearPlayerIntervals();
      tbody.innerHTML = "";

      let list = items.slice();
      if (forced) {
        list = list.slice(0, slots); // ignore extras
      }

      // Compute number of rows
      const rowCount = forced ? rows : Math.max(1, Math.ceil(list.length / cols));
      let i = 0;
      for (let r = 0; r < rowCount; r++) {
        const rowEl = document.createElement("tr");
        tbody.appendChild(rowEl);
        for (let c = 0; c < cols; c++) {
          if (i < list.length) {
            rowEl.appendChild(makeCell(list[i], i));
            i++;
          } else {
            if (forced) rowEl.appendChild(makeEmptyCell(i));
            i++;
          }
        }
      }
      ensureYouTubeAPI();
      requestAnimationFrame(resizeForFullscreen);
    }

    function resizeForFullscreen() {
      const wrapper = document.getElementById("gridWrapper");
      const isFs = document.fullscreenElement === wrapper || document.webkitFullscreenElement === wrapper;
      const iframes = Array.from(document.querySelectorAll("#tbody iframe"));
      const { cols, forced, rows } = getGridSettings();
      const rowCount = forced ? rows : Math.max(1, Math.ceil(iframes.length / cols));
      if (isFs) {
        const cw = wrapper.clientWidth, ch = wrapper.clientHeight;
        const spacing = 2;
        const cellW = Math.floor((cw - (cols+1)*spacing)/cols);
        const cellH = Math.floor((ch - (rowCount+1)*spacing)/rowCount);
        iframes.forEach((ifr) => { ifr.style.width = cellW+"px"; ifr.style.height = cellH+"px"; });
      } else {
        iframes.forEach((ifr) => { ifr.style.width = "560px"; ifr.style.height = "315px"; });
      }
    }

    function getSelectedSourceIndex() {
      const v = +localStorage.getItem(STORAGE_KEY);
      return Number.isInteger(v) && v >= 0 && v < SOURCES.length ? v : 0;
    }
    function setSelectedSourceIndex(i) { localStorage.setItem(STORAGE_KEY, String(i)); }
    function currentSourceUrl() {
      const sel = document.getElementById("sourceSelect");
      return SOURCES[sel.selectedIndex]?.url || SOURCES[0].url;
    }

    // â€”â€”â€” NEW: YouTube helpers to count & expand playlists
    function getApiKey() {
      const v = localStorage.getItem(KEY_STORE) || "";
      return v;
    }

    async function getPlaylistCount(playlistId) {
      const key = getApiKey();
      if (!key) return 1; // fallback: treat as single item if no API key
      const url = new URL("https://www.googleapis.com/youtube/v3/playlistItems");
      url.search = new URLSearchParams({
        key, part: "id", playlistId, maxResults: "1"
      }).toString();
      const r = await fetch(url.toString());
      if (!r.ok) return 1;
      const data = await r.json();
      const total = data?.pageInfo?.totalResults;
      return Number.isFinite(total) ? total : 1;
    }

    async function expandPlaylistVideos(playlistId, limit = Infinity) {
      const key = getApiKey();
      if (!key) return [{ kind:"playlist", id: playlistId }]; // cannot expand without API key
      const results = [];
      let pageToken = "";
      while (results.length < limit) {
        const batch = Math.min(50, limit - results.length);
        const url = new URL("https://www.googleapis.com/youtube/v3/playlistItems");
        url.search = new URLSearchParams({
          key,
          part: "contentDetails",
          playlistId,
          maxResults: String(batch),
          pageToken
        }).toString();
        const r = await fetch(url.toString());
        if (!r.ok) break;
        const data = await r.json();
        const vids = (data.items || [])
          .map(it => it.contentDetails?.videoId)
          .filter(Boolean)
          .map(id => ({ kind:"video", id }));
        results.push(...vids);
        pageToken = data.nextPageToken || "";
        if (!pageToken) break;
      }
      return results.length ? results : [{ kind:"playlist", id: playlistId }];
    }

    async function expandAllItems(items, cap) {
      const allowDup = document.getElementById("allowDuplicates").checked;
      const out = [];
      const seen = new Set();

      for (const it of items) {
        if (out.length >= cap) break;

        if (it.kind === "video") {
          const key = `video:${it.id}`;
          if (!allowDup && seen.has(key)) continue;
          seen.add(key);
          out.push(it);
        } else if (it.kind === "playlist") {
          const remaining = cap - out.length;
          const vids = await expandPlaylistVideos(it.id, remaining);
          for (const v of vids) {
            const key = `${v.kind}:${v.id}`;
            if (!allowDup && seen.has(key)) continue;
            seen.add(key);
            out.push(v);
            if (out.length >= cap) break;
          }
        }
      }
      return out;
    }

    function autoSetGridForCount(n) {
      // square-ish grid, capped to 12x12 UI constraints
      let cols = Math.ceil(Math.sqrt(Math.max(1, n)));
      cols = Math.min(12, Math.max(1, cols));
      let rows = Math.ceil(n / cols);
      rows = Math.min(12, Math.max(1, rows));
      // if still not enough (n > 144), we'll just fill up to 12*12
      document.getElementById("cols").value = String(cols);
      document.getElementById("rows").value = String(rows);
    }

    async function init() {
      const k = localStorage.getItem(KEY_STORE) || "";
      const keyInput = document.getElementById("ytApiKey");
      keyInput.value = k ? "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢" : "";
      document.getElementById("keyStatus").textContent = k ? "API key saved locally." : "No API key saved yet.";

      const status = document.getElementById("status");
      const error = document.getElementById("error");
      error.style.display = "none";
      status.textContent = "Loading linksâ€¦";

      try {
        const rawItems = await fetchItems(currentSourceUrl());

        // Count total videos represented by links (playlists expanded count when API key available)
        let totalCount = 0;
        for (const it of rawItems) {
          totalCount += (it.kind === "video") ? 1 : await getPlaylistCount(it.id);
          if (totalCount >= MAX_ITEMS) { totalCount = MAX_ITEMS; break; }
        }

        const settings0 = getGridSettings();

        // If not forcing a size, auto-pick a grid that fits the total video count
        if (!settings0.forced) {
          autoSetGridForCount(totalCount);
        }
        const settings = getGridSettings(); // read possibly updated cols/rows/slots

        // Expand playlists into actual video entries so the grid matches video count
        const display = await expandAllItems(rawItems, settings.forced ? settings.slots : MAX_ITEMS);

        // When forcing a fixed grid, trim or pad empties inside buildTable
        const missing = settings.forced ? Math.max(0, settings.slots - display.length) : 0;

        const summary = settings.forced
          ? `Loaded ${display.length}/${settings.slots} slot(s) from ${rawItems.length} link(s) â€” ${totalCount} video(s) detected.`
          : `Detected ${totalCount} video(s) from ${rawItems.length} link(s); auto-set grid to ${settings.cols}Ã—${settings.rows}.`;

        status.textContent = summary + (missing ? ` (showing ${missing} empty slot${missing===1?"":"s"})` : "");

        buildTable(display, settings);
      } catch (e) {
        status.textContent = "";
        error.textContent = e.message || String(e); error.style.display = "block"; console.error(e);
      }
    }

    (function setupSourceSelect() {
      const sel = document.getElementById("sourceSelect");
      sel.innerHTML = "";
      SOURCES.forEach(s => { const opt = document.createElement("option"); opt.textContent = s.label; sel.appendChild(opt); });
      sel.selectedIndex = getSelectedSourceIndex();
      sel.addEventListener("change", () => { setSelectedSourceIndex(sel.selectedIndex); init(); });
    })();

    document.getElementById("reload").addEventListener("click", init);
    document.getElementById("fullscreenBtn").addEventListener("click", () => {
      const wrapper = document.getElementById("gridWrapper");
      if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        (wrapper.requestFullscreen || wrapper.webkitRequestFullscreen)?.call(wrapper);
      } else {
        (document.exitFullscreen || document.webkitExitFullscreen)?.call(document);
      }
    });
    document.getElementById("resetBtn").addEventListener("click", resetProgress);
    document.addEventListener("fullscreenchange", resizeForFullscreen);
    document.addEventListener("webkitfullscreenchange", resizeForFullscreen);
    window.addEventListener("resize", resizeForFullscreen);

    // â€”â€”â€” Swap Mode (click two cells to swap)
    let swapMode = false;
    let firstCell = null;
    const swapBtn = document.getElementById('swapModeBtn');
    swapBtn.addEventListener('click', () => {
      swapMode = !swapMode;
      swapBtn.classList.toggle('toggle-on', swapMode);
      swapBtn.textContent = swapMode ? 'Swap Mode: ON' : 'Swap Mode';
      document.body.classList.toggle('swap-mode', swapMode);
      clearSwapHighlights(); firstCell = null;
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && swapMode) {
        swapMode = false; document.body.classList.remove('swap-mode');
        swapBtn.classList.remove('toggle-on'); swapBtn.textContent = 'Swap Mode';
        clearSwapHighlights(); firstCell = null;
      }
    });
    function clearSwapHighlights() {
      document.querySelectorAll('.cell').forEach(c => c.classList.remove('swap-highlight','swap-pending'));
    }
    function onCellClick(e) {
      if (!swapMode) return;
      const cell = e.currentTarget;
      if (!firstCell) { firstCell = cell; clearSwapHighlights(); cell.classList.add('swap-pending'); return; }
      if (cell === firstCell) { firstCell.classList.remove('swap-pending'); firstCell = null; return; }
      swapCellContents(firstCell, cell);
      firstCell.classList.remove('swap-pending'); cell.classList.add('swap-highlight');
      setTimeout(() => { cell.classList.remove('swap-highlight'); }, 400);
      firstCell = null; requestAnimationFrame(() => { ensureYouTubeAPI(); resizeForFullscreen(); });
    }
    function swapCellContents(cellA, cellB) {
      const tempA = document.createElement('div');
      while (cellA.firstChild) tempA.appendChild(cellA.firstChild);
      const tempB = document.createElement('div');
      while (cellB.firstChild) tempB.appendChild(cellB.firstChild);
      while (tempB.firstChild) cellA.appendChild(tempB.firstChild);
      while (tempA.firstChild) cellB.appendChild(tempA.firstChild);
      const hasIframeA = !!cellA.querySelector('iframe');
      const hasIframeB = !!cellB.querySelector('iframe');
      cellA.classList.toggle('empty', !hasIframeA);
      cellB.classList.toggle('empty', !hasIframeB);
    }

    // â€”â€”â€” API key handling
    document.getElementById("saveKeyBtn").addEventListener("click", () => {
      const input = document.getElementById("ytApiKey");
      const v = input.value.trim();
      if (!v) { localStorage.removeItem(KEY_STORE); document.getElementById("keyStatus").textContent = "Cleared API key."; return; }
      localStorage.setItem(KEY_STORE, v);
      input.value = "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢";
      document.getElementById("keyStatus").textContent = "API key saved locally.";
    });

    // â€”â€”â€” YouTube Search (Data API v3, embeddable only)
    async function searchYouTubeEmbeddable(query, needed, randomize=false) {
      const key = getApiKey();
      if (!key) throw new Error("Please provide a YouTube Data API key to use search.");
      const allowDup = document.getElementById("allowDuplicates").checked;

      const results = [];
      let pageToken = "";
      while (results.length < needed) {
        const batch = Math.min(50, needed - results.length);
        const url = new URL("https://www.googleapis.com/youtube/v3/search");
        url.search = new URLSearchParams({
          key,
          part: "snippet",
          q: query,
          maxResults: String(batch),
          type: "video",
          videoEmbeddable: "true",
          regionCode: REGION_CODE,
          safeSearch: "none",
          order: "relevance",
          pageToken
        }).toString();

        const r = await fetch(url.toString());
        if (!r.ok) {
          const text = await r.text();
          throw new Error(`YouTube API error: HTTP ${r.status}\n${text}`);
        }
        const data = await r.json();
        const vids = (data.items || []).map(it => it.id?.videoId).filter(Boolean);

        if (!allowDup) {
          const existing = new Set(results);
          vids.forEach(v => { if (!existing.has(v)) results.push(v); });
        } else {
          results.push(...vids);
        }

        pageToken = data.nextPageToken || "";
        if (!pageToken && results.length < needed) break;
      }

      let picked = results.slice(0);
      if (randomize) {
        for (let i=picked.length-1;i>0;i--) { const j=Math.floor(Math.random()*(i+1)); [picked[i],picked[j]]=[picked[j],picked[i]]; }
      }
      if (picked.length < needed && allowDup && picked.length > 0) {
        while (picked.length < needed) picked.push(picked[picked.length % results.length]);
      }
      return picked.slice(0, needed).map(id => ({ kind:"video", id }));
    }

    async function doSearchFill(randomize=false) {
      const q = (document.getElementById("searchInput").value || "").trim();
      const settings = getGridSettings();
      const total = settings.forced ? settings.slots : settings.cols * settings.rows;
      const status = document.getElementById("status");
      const error = document.getElementById("error");
      error.style.display = "none";

      if (!q) { error.textContent = "Please enter a search query."; error.style.display = "block"; return; }

      status.textContent = `Searching YouTube for â€œ${q}â€â€¦ (need ${total} embeddable video${total===1?'':'s'})`;
      try {
        const items = await searchYouTubeEmbeddable(q, total, randomize);
        if (!items.length) {
          error.textContent = "No embeddable videos found for that query.";
          error.style.display = "block"; status.textContent = ""; return;
        }
        const missing = Math.max(0, total - items.length);
        status.textContent = missing
          ? `Found ${items.length}/${total} video(s) for â€œ${q}â€.` 
          : `Loaded ${items.length} videos for â€œ${q}â€.`;
        buildTable(items, settings);
      } catch (e) {
        error.textContent = e.message || String(e);
        error.style.display = "block";
        status.textContent = "";
        console.error(e);
      }
    }

    document.getElementById("searchFillBtn").addEventListener("click", () => { doSearchFill(false); });
    document.getElementById("randomFillBtn").addEventListener("click", () => { doSearchFill(true); });

    // Programmatic helper: window.randomButton("lofi hip hop")
    window.randomButton = function(query) {
      document.getElementById("searchInput").value = query || "";
      doSearchFill(true);
    };

    // Boot
    init();
  </script>
</body>
</html>

