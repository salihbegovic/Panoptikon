<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Panoptikon 3.0 ‚Äî Videos & Playlists</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
      background: #0b0c10;
      color: #e8ecf1;
    }
    .wrap {
      max-width: 1800px;
      margin: 20px auto;
      padding: 12px;
    }
    h1 {
      font-size: clamp(20px,3.2vw,30px);
      margin: 0 0 12px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .badge {
      font-size: 11px;
      opacity: .8;
      padding: 2px 6px;
      border: 1px solid #2a303d;
      border-radius: 999px;
    }
    .hint {
      color: #a7b0bb;
      font-size: 14px;
      margin-bottom: 10px;
    }
    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      margin: 8px 0;
    }
    input[type="number"],
    input[type="text"],
    input[type="password"] {
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #2a303d;
      background: #0f1320;
      color: #e8ecf1;
    }
    input[type="number"] { width: 80px; }
    input[type="text"] { width: 260px; }
    input[type="password"] { width: 300px; }

    button {
      cursor: pointer;
      border: 1px solid #2a303d;
      background: #111827;
      color: #e8ecf1;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
    }
    button:disabled {
      opacity: .6;
      cursor: not-allowed;
    }
    .toggle-on {
      background: #0b3a2b;
      border-color: #134e4a;
    }

    #qrCode {
      position: static;
      z-index: 10;
    }

    /* QR overlay bottom-right in fullscreen (Telegram only) */
    #qrCodeOverlay {
      position: fixed;
      bottom: 16px;
      right: 16px;
      width: 160px;
      height: auto;
      z-index: 9999;
      pointer-events: none;
      display: none;
    }
    #gridWrapper:fullscreen #qrCodeOverlay.show,
    #gridWrapper:-webkit-full-screen #qrCodeOverlay.show {
      display: block;
    }

    .sources {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      gap: 12px;
      margin: 14px 0 6px;
    }
    .source-card {
      background: #0d1117;
      border: 1px solid #1c2230;
      border-radius: 12px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: transform .1s ease, box-shadow .1s ease, border-color .1s ease;
      cursor: pointer;
      min-height: 180px;
    }
    .source-card:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 24px rgba(0,0,0,.25);
      border-color: #2a303d;
    }
    .source-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .source-title {
      font-weight: 700;
      font-size: 14px;
      letter-spacing: .02em;
    }
    .counts {
      font-size: 12px;
      color: #9aa5b1;
      display: flex;
      gap: 8px;
    }

    .preview-shell {
      position: relative;
      border: 1px solid #1c2230;
      border-radius: 10px;
      background: #0b0f18;
      padding: 6px;
      overflow: hidden;
      height: 240px;
    }
    .preview-scale {
      position: absolute;
      top: 6px;
      left: 6px;
      transform-origin: top left;
    }
    .preview-grid {
      display: grid;
      gap: 6px;
      background: transparent;
    }
    .preview-tile {
      position: relative;
      width: 160px;
      padding-top: 56.25%;
      border-radius: 8px;
      overflow: hidden;
      background: #0f1320;
      border: 1px solid #1c2230;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #94a3b8;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: .06em;
    }
    .preview-tile img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .active-source {
      outline: 2px solid #7dd3fc;
      box-shadow: 0 0 0 3px rgba(125,211,252,.25) inset;
    }

    /* --- Grid container replaces table --- */
    #grid {
      display: grid;
      gap: 6px;
      width: 100%;
    }
    #gridWrapper:fullscreen #grid,
    #gridWrapper:-webkit-full-screen #grid {
      gap: 2px;
    }
    .grid-cell {
      background: #0d1117;
      border: 1px solid #1c2230;
      border-radius: 8px;
      padding: 0;
    }

    .video-container {
      position: relative;
      width: 100%;
      padding-top: 56.25%;
      overflow: hidden;
      border-radius: 6px;
      transition: padding-top .12s ease;
    }
    .video-container iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
      border-radius: 6px;
    }

    /* Transparent click-catcher over each YouTube iframe */
    .video-overlay {
      position: absolute;
      inset: 0;
      z-index: 5;
      background: transparent;
      cursor: pointer;
    }

    /* If overlay controls are OFF, let the iframe receive all clicks */
    body.overlays-off .video-overlay {
      pointer-events: none;
      display: none;
    }

    /* In swap mode, let clicks go to the cell (for swapping), not the overlay */
    .swap-mode .video-overlay {
      pointer-events: none;
    }

    .cell {
      position: relative;
      border-radius: 8px;
    }
    .cell.swap-highlight {
      outline: 2px solid #7dd3fc;
      box-shadow: 0 0 0 3px rgba(125,211,252,.25) inset;
    }
    .cell.swap-pending {
      outline: 2px solid #a78bfa;
      box-shadow: 0 0 0 3px rgba(167,139,250,.25) inset;
    }

    .error {
      background: #2b1414;
      border: 1px solid #3b1a1a;
      color: #ffd5d5;
      padding: 10px;
      border-radius: 10px;
      white-space: pre-wrap;
    }

    #gridWrapper:fullscreen {
      width: 100vw;
      height: 100vh;
      margin: 0;
    }
    #gridWrapper:-webkit-full-screen {
      width: 100vw;
      height: 100vh;
    }

    .swap-mode iframe {
      pointer-events: none;
      filter: saturate(0.9) brightness(0.95);
    }
    .swap-mode .cell {
      cursor: crosshair;
    }
    .swap-mode .cell.swap-pending {
      outline: 2px dashed #a78bfa;
      box-shadow: 0 0 0 3px rgba(167,139,250,.25) inset;
    }

    .cell.empty {
      display: flex;
      align-items: center;
      justify-content: center;
      color: #6b7280;
      border: 1px dashed #2a303d;
      border-radius: 8px;
      background: repeating-linear-gradient(
        45deg,
        #0d1117,
        #0d1117 8px,
        #0f1320 8px,
        #0f1320 16px
      );
      font-size: 12px;
      letter-spacing: .04em;
      text-transform: uppercase;
      min-height: 200px;
    }
    #gridWrapper:fullscreen .cell.empty {
      min-height: unset;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .spacer { flex: 1; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>üì∫ Panoptikon 3.0 <span class="badge">Ich ficke deine Mutter</span></h1>
    <img id="qrCode" src="QRCodeSheets.png" alt="QR Code" width="200" height="200"><br>
    <a href="https://docs.google.com/spreadsheets/d/1wtC8tG9LB4RhvqWBPHyJdBDbvtlwXkd1IcvXL8AR_yM/edit?usp=sharing" target="_blank">
      The links are to be put in the google sheet
    </a>

    <div class="row" style="margin-top:10px;">
      <div class="hint">Everything old - once was young. Everything young - someday dies.</div>
      <div class="spacer"></div>
      <span class="hint" id="previewStatus"></span>
    </div>

    <div id="sourcesPreview" class="sources"></div>

    <div class="controls">
      <label>Columns: <input id="cols" type="number" min="1" max="12" value="5"></label>
      <label>Rows: <input id="rows" type="number" min="1" max="12" value="5"></label>
      <label><input type="checkbox" id="forceGrid"> Force grid size</label>
      <label><input type="checkbox" id="allowDuplicates" checked> Allow Duplicates</label>
      <button id="reload">Rebuild Grid</button>
      <button id="fullscreenBtn">Fullscreen</button>
      <button id="overlayToggleBtn" title="When ON: click=mute, double-click=grid fullscreen. When OFF: use YouTube controls.">Max Mode: ON</button>
      <button id="aspectModeBtn" title="Toggle tile aspect behavior">Aspect: 16:9</button>
      <button id="resetBtn">Reset Progress</button>
      <button id="swapModeBtn" title="Click to enable swap, then click two videos to swap their positions">Swap Mode</button>
      <button id="saveLayoutBtn">Save Layout</button>
      <button id="clearLayoutBtn">Clear Layout</button>
      <button id="expandPlaylistsBtn">Playlists: ONE item</button>
    </div>

    <div class="controls">
      <input id="searchInput" type="text" placeholder="Search YouTube (e.g. ambient music)" />
      <button id="searchFillBtn">Search Fill</button>
      <button id="randomFillBtn">Random Fill</button>
      <span class="hint">If "Force grid size" is on, search fetches exactly Rows√óColumns.</span>
    </div>

    <div class="controls">
      <input id="ytApiKey" type="password" placeholder="YouTube Data API key (stored locally)" />
      <button id="saveKeyBtn">Save Key</button>
      <span class="hint" id="keyStatus"></span>
    </div>

    <div id="status" class="hint"></div>
    <div id="loadedCount" class="hint" style="margin-top:4px; opacity:.9;"></div>
    <div id="error" class="error" style="display:none"></div>

    <div id="gridWrapper">
      <img id="qrCodeOverlay" src="QRCodeTelegram.png" alt="QR Code">
      <div id="grid"></div>
    </div>
  </div>

  <script>
    /***********************
     * Config
     ***********************/
    const SOURCES = [
      { label: "Sheet 1", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=0&single=true&output=csv" },
      { label: "Sheet 2", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=331016320&single=true&output=csv" },
      { label: "Sheet 3", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=181596337&single=true&output=csv" },
      { label: "Sheet 4", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=362795220&single=true&output=csv" },
      { label: "Sheet 5", url: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRU3kIRYgXYQvfM6aN-qSLklE3ani0JY1cQqEGljkzemrYVAeDNZeTHDFC8cm80tvou_WtbyB7V9-ek/pub?gid=1039723187&single=true&output=csv" },
      { label: "Telegram Chat", url: "youtube_links.txt" }
    ];

    const TELEGRAM_LABEL = "Telegram Chat";
    const TELEGRAM_MAX_VIDEOS = 25;
    const TELEGRAM_POLL_INTERVAL = 3000;

    const STORAGE_SELECTED    = "panoptikon_selected_index";
    const POS_PREFIX          = "panoptikon_time_";
    const KEY_STORE           = "panoptikon_yt_api_key";
    const REGION_CODE         = "AT";
    const MAX_ITEMS           = 200;
    const EXPAND_STORE        = "panoptikon_expand_playlists";
    const LAYOUT_STORE_PREFIX = "panoptikon_layout_";
    const ASPECT_MODE_STORE   = "panoptikon_aspect_mode";
    const OVERLAY_CTRL_STORE  = "panoptikon_overlay_controls";

    let telegramLastLineCount = 0;
    let telegramLiveTimer = null;
    let ytApiReady = false;
    const playerIntervals = new Map();
    const cache = new Map();
    let telegramDisplayKeys = [];

    let expandPlaylists = getExpandPref();
    let swapMode = false;
    let firstCell = null;

    const players = new Map();
    let clickTimer = null;
    let scrollBeforeFullscreen = 0;

    /***********************
     * Overlay controls pref
     ***********************/
    function getOverlayControlsEnabled() {
      const v = localStorage.getItem(OVERLAY_CTRL_STORE);
      return v === null ? true : (v === "1");
    }
    function setOverlayControlsEnabled(v) {
      localStorage.setItem(OVERLAY_CTRL_STORE, v ? "1" : "0");
    }
    function applyOverlayControlsState() {
      const enabled = getOverlayControlsEnabled();
      document.body.classList.toggle("overlays-off", !enabled);
      const btn = document.getElementById("overlayToggleBtn");
      if (btn) {
        btn.textContent = enabled ? "Max Mode: ON" : "Max Mode: OFF";
        btn.classList.toggle("toggle-on", enabled);
      }
    }

    /***********************
     * Utility
     ***********************/
    function layoutKey() {
      const label = SOURCES[getSelectedIndex()]?.label || "Sheet";
      return `${LAYOUT_STORE_PREFIX}${label}:${expandPlaylists ? "expanded" : "one"}`;
    }

    function getItemKey(it) {
      return `${it.kind}:${it.id || ""}:${it.startVideoId || ""}`;
    }

    function parseYouTube(x) {
      if (!x) return null;
      x = ("" + x).trim();

      if (/^[a-zA-Z0-9_-]{11}$/.test(x)) {
        return { kind: "video", id: x };
      }

      if (!/^https?:\/\//i.test(x)) x = "https://" + x;

      let u;
      try { u = new URL(x); } catch { return null; }

      const host = u.hostname.replace(/^www\./, "");
      const v = u.searchParams.get("v") || undefined;
      const list = u.searchParams.get("list") || undefined;

      if (host === "youtu.be") {
        const vid = u.pathname.split("/").filter(Boolean)[0];
        if (vid && /^[a-zA-Z0-9_-]{11}$/.test(vid)) return { kind: "video", id: vid };
        return null;
      }

      if (!/youtube\.com$/.test(host)) return null;

      if (list && /^[a-zA-Z0-9_-]{3,}$/.test(list)) {
        return {
          kind: "playlist",
          id: list,
          startVideoId: (v && /^[a-zA-Z0-9_-]{11}$/.test(v)) ? v : undefined
        };
      }

      if (v && /^[a-zA-Z0-9_-]{11}$/.test(v)) {
        return { kind: "video", id: v };
      }

      let m = u.pathname.match(/\/shorts\/([a-zA-Z0-9_-]{5,})/);
      if (m) return { kind: "video", id: m[1].slice(0, 11) };

      m = u.pathname.match(/\/embed\/([a-zA-Z0-9_-]{5,})/);
      if (m) return { kind: "video", id: m[1].slice(0, 11) };

      const tail = u.pathname.split("/").filter(Boolean).pop();
      if (tail && /^[a-zA-Z0-9_-]{5,}$/.test(tail)) {
        return { kind: "video", id: tail.slice(0, 11) };
      }

      return null;
    }

    function embedUrl(item) {
      const baseParams = {
        autoplay: "1",
        mute: "1",
        wmode: "opaque",
        autohide: "1",
        enablejsapi: "1",
        start: "0",
        iv_load_policy: "3",
        rel: "0",
        playsinline: "1"
      };

      if (item.kind === "video") {
        const params = new URLSearchParams(baseParams);
        params.set("loop", "1");
        params.set("playlist", item.id);
        return `https://www.youtube.com/embed/${item.id}?${params.toString()}`;
      }

      if (item.kind === "playlist") {
        const params = new URLSearchParams(baseParams);
        params.set("listType", "playlist");
        params.set("list", item.id);
        if (item.startVideoId) params.set("v", item.startVideoId);
        return `https://www.youtube.com/embed?${params.toString()}`;
      }

      return "about:blank";
    }

    /***********************
     * Fullscreen helpers
     ***********************/
    function toggleGridFullscreen() {
      const wrapper = document.getElementById("gridWrapper");
      const isEntering =
        !document.fullscreenElement &&
        !document.webkitFullscreenElement;

      if (isEntering) {
        scrollBeforeFullscreen = window.scrollY || window.pageYOffset || 0;
        (wrapper.requestFullscreen || wrapper.webkitRequestFullscreen)?.call(wrapper);
      } else {
        (document.exitFullscreen || document.webkitExitFullscreen)?.call(document);
      }
    }

    function toggleMuteForIframe(iframeId) {
      const p = players.get(iframeId);
      if (!p) return;
      try {
        if (p.isMuted && p.isMuted()) p.unMute();
        else p.mute();
      } catch {}
    }

    /***********************
     * YouTube API + progress
     ***********************/
    function ensureYouTubeAPI() {
      if (window.YT && YT.Player) {
        ytApiReady = true;
        initPlayers();
        return;
      }
      if (document.getElementById("yt-iframe-api")) return;
      const tag = document.createElement("script");
      tag.id = "yt-iframe-api";
      tag.src = "https://www.youtube.com/iframe_api";
      document.head.appendChild(tag);
      window.onYouTubeIframeAPIReady = () => {
        ytApiReady = true;
        initPlayers();
      };
    }

    function clearPlayerIntervals() {
      for (const i of playerIntervals.values()) clearInterval(i);
      playerIntervals.clear();
      players.clear();
    }

    function initPlayers() {
      if (!ytApiReady) return;
      const iframes = Array.from(document.querySelectorAll("#grid iframe[data-progress-key]"));
      iframes.forEach((ifr) => {
        if (ifr.dataset.bound === "1") return;
        const pkey = ifr.dataset.progressKey;
        const player = new YT.Player(ifr.id, {
          events: {
            onReady: (e) => {
              const t = loadTime(pkey);
              if (t > 1) {
                try { e.target.seekTo(t, true); } catch {}
              }
              try { e.target.playVideo(); } catch {}
            },
            onStateChange: (e) => {
              try {
                const cur = e.target.getCurrentTime?.();
                if (Number.isFinite(cur)) saveTime(pkey, cur);
              } catch {}
            }
          }
        });

        players.set(ifr.id, player);

        const intervalId = setInterval(() => {
          try {
            const cur = player.getCurrentTime();
            if (Number.isFinite(cur)) saveTime(pkey, cur);
          } catch {}
        }, 3000);
        playerIntervals.set(ifr.id, intervalId);
        ifr.dataset.bound = "1";
      });
    }

    function saveTime(key, seconds) {
      try {
        localStorage.setItem(POS_PREFIX + key, String(Math.floor(seconds)));
      } catch {}
    }

    function loadTime(key) {
      const v = +localStorage.getItem(POS_PREFIX + key);
      return Number.isFinite(v) && v > 0 ? v : 0;
    }

    function resetProgress() {
      Object.keys(localStorage).forEach(k => {
        if (k.startsWith(POS_PREFIX)) localStorage.removeItem(k);
      });
      clearSavedLayout();
      init();
    }

    /***********************
     * Grid
     ***********************/
    function getGridSettings() {
      const cols = Math.max(1, Math.min(12, +document.getElementById("cols").value || 5));
      const forced = !!document.getElementById("forceGrid").checked;
      const rows = Math.max(1, Math.min(12, +document.getElementById("rows").value || (forced ? cols : 5)));
      return { cols, rows, forced, slots: cols * rows };
    }

    function makeCell(item, idx) {
      const cell = document.createElement("div");
      cell.className = "cell grid-cell";
      cell.dataset.cellIndex = String(idx);

      const container = document.createElement("div");
      container.className = "video-container";

      const ifr = document.createElement("iframe");
      const iframeId = `playeryt_${item.kind}_${(item.id || "")}_${Date.now()}_${Math.random().toString(36).slice(2,7)}`;
      ifr.id = iframeId;
      ifr.src = embedUrl(item);
      ifr.allow = "autoplay; clipboard-write; encrypted-media; picture-in-picture; accelerometer; gyroscope; fullscreen";
      ifr.setAttribute("allowfullscreen", "");
      ifr.dataset.progressKey = getItemKey(item);

      container.appendChild(ifr);

      const overlay = document.createElement("div");
      overlay.className = "video-overlay";

      overlay.addEventListener("click", (ev) => {
        if (swapMode) return;
        ev.preventDefault();
        ev.stopPropagation();

        if (clickTimer) clearTimeout(clickTimer);
        clickTimer = setTimeout(() => {
          toggleMuteForIframe(ifr.id);
          clickTimer = null;
        }, 220);
      });

      overlay.addEventListener("dblclick", (ev) => {
        if (swapMode) return;
        ev.preventDefault();
        ev.stopPropagation();

        if (clickTimer) { clearTimeout(clickTimer); clickTimer = null; }
        toggleGridFullscreen();
      });

      container.appendChild(overlay);
      cell.appendChild(container);

      cell.addEventListener("click", onCellClick);
      return cell;
    }

    function makeEmptyCell(idx) {
      const cell = document.createElement("div");
      cell.className = "cell empty grid-cell";
      cell.dataset.cellIndex = String(idx);
      cell.textContent = "Empty";
      cell.addEventListener("click", onCellClick);
      return cell;
    }

    function buildTable(items, settings) {
      const { cols, forced, slots } = settings;
      const grid = document.getElementById("grid");

      clearPlayerIntervals();
      grid.innerHTML = "";

      grid.style.gridTemplateColumns = `repeat(${cols}, minmax(0, 1fr))`;

      let list = items.slice();
      if (forced) list = list.slice(0, slots);

      const targetCount = forced ? slots : list.length;

      for (let i = 0; i < targetCount; i++) {
        if (i < list.length) {
          grid.appendChild(makeCell(list[i], i));
        } else {
          grid.appendChild(makeEmptyCell(i));
        }
      }

      ensureYouTubeAPI();
      requestAnimationFrame(resizeGrid);
    }

    function resizeGrid() {
      const wrapper = document.getElementById("gridWrapper");
      const isFS =
        document.fullscreenElement === wrapper ||
        document.webkitFullscreenElement === wrapper;

      if (!isFS) {
        const top = wrapper.getBoundingClientRect().top;
        const targetH = Math.max(220, window.innerHeight - top - 16);
        wrapper.style.height = `${Math.floor(targetH)}px`;
      }

      const { cols, rows } = getGridSettings();
      const spacing = isFS ? 2 : 6;
      const rect = wrapper.getBoundingClientRect();
      const availW = Math.max(0, rect.width - spacing * (cols + 1));
      const availH = Math.max(0, rect.height - spacing * (rows + 1));
      if (availW <= 0 || availH <= 0) return;

      const containers = wrapper.querySelectorAll(".video-container");

      if (getAspectMode() === "fixed") {
        containers.forEach(c => { c.style.paddingTop = "56.25%"; });
        return;
      }

      const cellW = availW / cols;
      const cellH = availH / rows;
      const pct = Math.max(20, Math.min(150, (cellH / cellW) * 100));
      containers.forEach(c => { c.style.paddingTop = pct + "%"; });
    }

    /***********************
     * Layout save / load helpers (restored for DIV grid)
     ***********************/
    function saveCurrentLayout() {
      const order = Array.from(document.querySelectorAll("#grid .cell iframe"))
        .map(ifr => ifr?.dataset?.progressKey)
        .filter(Boolean);
      try {
        localStorage.setItem(layoutKey(), JSON.stringify(order));
      } catch {}
      const s = document.getElementById("status");
      if (s) s.textContent = "Layout saved.";
    }

    function loadSavedLayout() {
      try {
        const raw = localStorage.getItem(layoutKey());
        return raw ? JSON.parse(raw) : null;
      } catch {
        return null;
      }
    }

    function clearSavedLayout() {
      localStorage.removeItem(layoutKey());
    }

    /***********************
     * Search (kept)
     ***********************/
    function getApiKey() {
      return localStorage.getItem(KEY_STORE) || "";
    }

    async function searchYouTubeEmbeddable(query, needed, randomize = false) {
      const key = getApiKey();
      if (!key) throw new Error("Please provide a YouTube Data API key to use search.");
      const allowDup = document.getElementById("allowDuplicates").checked;
      const results = [];
      let pageToken = "";

      while (results.length < needed) {
        const batch = Math.min(50, needed - results.length);
        const url = new URL("https://www.googleapis.com/youtube/v3/search");
        url.search = new URLSearchParams({
          key,
          part: "snippet",
          q: query,
          maxResults: String(batch),
          type: "video",
          videoEmbeddable: "true",
          regionCode: REGION_CODE,
          safeSearch: "none",
          order: "relevance",
          pageToken
        }).toString();

        const r = await fetch(url.toString());
        if (!r.ok) {
          const text = await r.text();
          throw new Error(`YouTube API error: HTTP ${r.status}\n${text}`);
        }
        const data = await r.json();
        const vids = (data.items || []).map(it => it.id?.videoId).filter(Boolean);

        if (!allowDup) {
          const existing = new Set(results);
          vids.forEach(v => { if (!existing.has(v)) results.push(v); });
        } else {
          results.push(...vids);
        }

        pageToken = data.nextPageToken || "";
        if (!pageToken && results.length < needed) break;
      }

      let picked = results.slice(0);
      if (randomize) {
        for (let i = picked.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [picked[i], picked[j]] = [picked[j], picked[i]];
        }
      }

      if (picked.length < needed && allowDup && picked.length > 0) {
        while (picked.length < needed) picked.push(picked[picked.length % results.length]);
      }

      return picked.slice(0, needed).map(id => ({ kind: "video", id }));
    }

    async function doSearchFill(randomize = false) {
      const q = (document.getElementById("searchInput").value || "").trim();
      const settings = getGridSettings();
      const total = settings.forced ? settings.slots : settings.cols * settings.cols;
      const status = document.getElementById("status");
      const error = document.getElementById("error");
      error.style.display = "none";

      if (!q) {
        error.textContent = "Please enter a search query.";
        error.style.display = "block";
        return;
      }

      status.textContent = `Searching YouTube for ‚Äú${q}‚Äù‚Ä¶ (need ${total} embeddable video${total === 1 ? "" : "s"})`;
      try {
        const items = await searchYouTubeEmbeddable(q, total, randomize);
        if (!items.length) {
          error.textContent = "No embeddable videos found for that query.";
          error.style.display = "block";
          status.textContent = "";
          return;
        }
        const missing = Math.max(0, total - items.length);
        status.textContent = missing
          ? `Found ${items.length}/${total} video(s) for ‚Äú${q}‚Äù.`
          : `Loaded ${items.length} videos for ‚Äú${q}‚Äù.`;
        buildTable(items, settings);
        updateLoadedCounts(items);
      } catch (e) {
        error.textContent = e.message || String(e);
        error.style.display = "block";
        status.textContent = "";
        console.error(e);
      }
    }

    /***********************
     * Playlist expansion
     ***********************/
    function getExpandPref() {
      return localStorage.getItem(EXPAND_STORE) === "1";
    }
    function setExpandPref(v) {
      localStorage.setItem(EXPAND_STORE, v ? "1" : "0");
    }

    async function fetchPlaylistVideos(playlistId, maxTotal = MAX_ITEMS) {
      const key = getApiKey();
      if (!key) throw new Error("Expanding playlists needs a YouTube Data API key. Save one above and try again.");
      const out = [];
      let pageToken = "";
      while (out.length < maxTotal) {
        const url = new URL("https://www.googleapis.com/youtube/v3/playlistItems");
        url.search = new URLSearchParams({
          key,
          part: "contentDetails",
          playlistId,
          maxResults: "50",
          pageToken
        }).toString();
        const r = await fetch(url.toString());
        if (!r.ok) {
          const txt = await r.text();
          throw new Error(`YouTube API error for playlist ${playlistId}: HTTP ${r.status}\n${txt}`);
        }
        const data = await r.json();
        const vids = (data.items || []).map(it => it.contentDetails?.videoId).filter(Boolean);
        out.push(...vids);
        pageToken = data.nextPageToken || "";
        if (!pageToken) break;
      }
      return out.map(id => ({ kind: "video", id }));
    }

    async function expandPlaylistsIfEnabled(items, expand) {
      if (!expand) return items;
      const allowDup = document.getElementById("allowDuplicates").checked;
      const status = document.getElementById("status");
      const error = document.getElementById("error");

      const seen = new Set();
      const push = (arr, it) => {
        if (allowDup) { arr.push(it); return true; }
        const k = `video:${it.id}`;
        if (seen.has(k)) return false;
        seen.add(k);
        arr.push(it);
        return true;
      };

      if (!allowDup) {
        items.forEach(it => { if (it.kind === "video") seen.add(`video:${it.id}`); });
      }

      const out = [];
      let playlistsExpanded = 0;
      for (const it of items) {
        if (out.length >= MAX_ITEMS) break;
        if (it.kind === "playlist") {
          try {
            status.textContent = `Expanding playlist ${playlistsExpanded + 1}‚Ä¶`;
            const vids = await fetchPlaylistVideos(it.id, MAX_ITEMS);
            for (const v of vids) {
              if (out.length >= MAX_ITEMS) break;
              push(out, { kind: "video", id: v });
            }
            playlistsExpanded++;
          } catch (e) {
            console.warn(e);
            error.style.display = "block";
            error.textContent = (error.textContent ? error.textContent + "\n" : "") + (e.message || String(e));
            out.push(it);
          }
        } else {
          push(out, it);
        }
      }
      status.textContent = `Expanded ${playlistsExpanded} playlist${playlistsExpanded === 1 ? "" : "s"} into videos.`;
      return out.slice(0, MAX_ITEMS);
    }

    /***********************
     * Source selection + previews
     ***********************/
    function getSelectedIndex() {
      let v = +localStorage.getItem(STORAGE_SELECTED);
      if (!Number.isInteger(v) || v < 0 || v >= SOURCES.length) v = 5;
      return v;
    }

    function setSelectedIndex(i) {
      const clamped = Math.max(0, Math.min(SOURCES.length - 1, i | 0));
      localStorage.setItem(STORAGE_SELECTED, String(clamped));
    }

    function itemCounts(items) {
      return items.reduce((acc, it) => {
        acc[it.kind] = (acc[it.kind] || 0) + 1;
        return acc;
      }, {});
    }

    function ytThumbUrl(id) {
      return `https://i.ytimg.com/vi/${id}/mqdefault.jpg`;
    }

    async function loadAllSources() {
      const previewStatus = document.getElementById("previewStatus");
      previewStatus.textContent = "Loading sources‚Ä¶";
      const tasks = SOURCES.map(async (src) => {
        const items = await fetchItems(src.url);
        cache.set(src.label, { items, counts: itemCounts(items) });
      });
      await Promise.all(tasks);
      buildSourcesPreview();
      previewStatus.textContent = `Loaded ${SOURCES.length} source(s).`;
    }

    function computeOptimalGrid(n) {
      n = Math.max(1, Math.min(144, n));
      let best = { cols: 1, rows: n, waste: 0, aspect: Infinity };
      for (let cols = 1; cols <= Math.min(12, n); cols++) {
        const rows = Math.ceil(n / cols);
        if (rows > 12) continue;
        const slots = cols * rows;
        const waste = slots - n;
        const aspect = Math.abs(cols - rows);
        const better =
          waste < best.waste ||
          (waste === best.waste && aspect < best.aspect) ||
          (waste === best.waste && aspect === best.aspect && rows < best.rows);
        if (better) best = { cols, rows, waste, aspect };
      }
      return { cols: best.cols, rows: best.rows, slots: best.cols * best.rows };
    }

    function buildSourcesPreview() {
      const wrap = document.getElementById("sourcesPreview");
      wrap.innerHTML = "";
      const selectedIdx = getSelectedIndex();

      SOURCES.forEach((src, idx) => {
        const data = cache.get(src.label);
        const card = document.createElement("div");
        card.className = "source-card";
        if (idx === selectedIdx) card.classList.add("active-source");

        const head = document.createElement("div");
        head.className = "source-head";
        const title = document.createElement("div");
        title.className = "source-title";
        title.textContent = src.label + (src.label === TELEGRAM_LABEL ? " (Live)" : " (Auto)");
        const countsEl = document.createElement("div");
        countsEl.className = "counts";
        const v = data?.counts?.video || 0;
        const p = data?.counts?.playlist || 0;
        countsEl.textContent =
          `${v} video${v === 1 ? "" : "s"}` +
          (p ? ` ¬∑ ${p} playlist${p === 1 ? "" : "s"}` : "");
        head.appendChild(title);
        head.appendChild(countsEl);

        const shell = document.createElement("div");
        shell.className = "preview-shell";
        const scaleWrap = document.createElement("div");
        scaleWrap.className = "preview-scale";
        const grid = document.createElement("div");
        grid.className = "preview-grid";

        const TILE_W = 160;
        const GAP = 6;
        const TILE_H = Math.round(TILE_W * 9 / 16);

        let items = (data?.items || []);
        let cols, rows, slots;

        if (src.label === TELEGRAM_LABEL) {
          const recent = items.slice(0, 25);
          items = recent;
          cols = 5;
          rows = 5;
          slots = 25;
          grid.style.gridTemplateColumns = `repeat(5, ${TILE_W}px)`;
        } else {
          const opt = computeOptimalGrid(items.length || 1);
          cols = opt.cols;
          rows = opt.rows;
          slots = opt.slots;
          grid.style.gridTemplateColumns = `repeat(${cols}, ${TILE_W}px)`;
        }

        const naturalW = cols * TILE_W + (cols - 1) * GAP;
        const naturalH = rows * TILE_H + (rows - 1) * GAP;

        for (let i = 0; i < slots; i++) {
          const t = document.createElement("div");
          t.className = "preview-tile";
          const it = items[i];
          if (it && it.kind === "video" && /^[a-zA-Z0-9_-]{11}$/.test(it.id)) {
            const img = document.createElement("img");
            img.loading = "lazy";
            img.decoding = "async";
            img.src = ytThumbUrl(it.id);
            img.alt = "Video";
            t.appendChild(img);
          } else if (it && it.kind === "playlist" && it.startVideoId) {
            const img = document.createElement("img");
            img.loading = "lazy";
            img.decoding = "async";
            img.src = ytThumbUrl(it.startVideoId);
            img.alt = "Playlist";
            t.appendChild(img);
          } else if (it && it.kind === "playlist") {
            t.textContent = "PL";
          } else {
            t.textContent = "‚Äî";
          }
          grid.appendChild(t);
        }

        scaleWrap.appendChild(grid);
        shell.appendChild(scaleWrap);
        queueMicrotask(() => {
          const cardWidth = card.clientWidth - 20;
          const maxHeight = 240;
          const scale = Math.min(cardWidth / naturalW, maxHeight / naturalH, 1);
          scaleWrap.style.transform = `scale(${Number.isFinite(scale) && scale > 0 ? scale : 1})`;
        });

        card.appendChild(head);
        card.appendChild(shell);

        card.addEventListener("click", () => {
          setSelectedIndex(idx);
          Array.from(document.querySelectorAll(".source-card"))
            .forEach(c => c.classList.remove("active-source"));
          card.classList.add("active-source");
          loadSelectedIntoGrid(idx);
          updateFullscreenQr();
        });

        wrap.appendChild(card);
      });
    }

    function getCurrentItemsForIndex(idx) {
      const label = SOURCES[idx]?.label;
      return cache.get(label)?.items || [];
    }

    async function loadSelectedIntoGrid(idx) {
      const error = document.getElementById("error");
      const status = document.getElementById("status");
      const loadedCountEl = document.getElementById("loadedCount");
      error.style.display = "none";
      status.textContent = "Preparing grid‚Ä¶";
      loadedCountEl.textContent = "";

      try {
        const label = SOURCES[idx]?.label || "Source";
        let items = getCurrentItemsForIndex(idx).slice(0, MAX_ITEMS);

        if (expandPlaylists && label !== TELEGRAM_LABEL) {
          items = await expandPlaylistsIfEnabled(items, true);
        }

        // Apply saved layout for non-telegram
        if (label !== TELEGRAM_LABEL) {
          const savedOrder = loadSavedLayout();
          if (Array.isArray(savedOrder) && savedOrder.length) {
            const byKey = new Map(items.map(it => [getItemKey(it), it]));
            const picked = [];
            const seen = new Set();
            for (const k of savedOrder) {
              const it = byKey.get(k);
              if (it && !seen.has(k)) { picked.push(it); seen.add(k); }
            }
            for (const it of items) {
              const k = getItemKey(it);
              if (!seen.has(k)) { picked.push(it); seen.add(k); }
            }
            items = picked;
          }
        }

        const forceGridEl = document.getElementById("forceGrid");
        if (label !== TELEGRAM_LABEL && !forceGridEl.checked) {
          const n = items.length || 1;
          const opt = computeOptimalGrid(n);
          document.getElementById("cols").value = String(opt.cols);
          document.getElementById("rows").value = String(opt.rows);
        }

        const settings = getGridSettings();
        let display;

        if (label === TELEGRAM_LABEL) {
          const newestFirst = items.slice(0, TELEGRAM_MAX_VIDEOS);
          const limit = settings.forced ? settings.slots : TELEGRAM_MAX_VIDEOS;
          display = newestFirst.slice(0, limit);
          buildTable(display, settings);
          telegramDisplayKeys = display.map(getItemKey);
        } else {
          display = settings.forced ? items.slice(0, settings.slots) : items;
          buildTable(display, settings);
        }

        loadedCountEl.textContent =
          `Loaded embeds: ${display.length} from ${label}` +
          (expandPlaylists && label !== TELEGRAM_LABEL ? " (playlists expanded)" : "");

        status.textContent = settings.forced
          ? `Loaded ${display.length}/${settings.slots} slot(s) from ${label}.`
          : `Loaded ${display.length} item${display.length === 1 ? "" : "s"} from ${label}. (Grid: ${document.getElementById("cols").value}√ó${document.getElementById("rows").value})`;

        updateFullscreenQr();
      } catch (e) {
        status.textContent = "";
        document.getElementById("loadedCount").textContent = "";
        error.textContent = e.message || String(e);
        error.style.display = "block";
        console.error(e);
      }
    }

    function updateLoadedCounts(displayItems) {
      document.getElementById("loadedCount").textContent =
        `Loaded embeds: ${displayItems.length}`;
    }

    /***********************
     * ‚úÖ Swap mode (RESTORED for DIV grid, no reload)
     ***********************/
    const swapBtn = document.getElementById("swapModeBtn");

    function clearSwapHighlights() {
      document.querySelectorAll(".cell").forEach(c =>
        c.classList.remove("swap-highlight", "swap-pending")
      );
    }

    function setSwapMode(on) {
      swapMode = !!on;
      document.body.classList.toggle("swap-mode", swapMode);

      if (swapBtn) {
        swapBtn.classList.toggle("toggle-on", swapMode);
        swapBtn.textContent = swapMode ? "Swap Mode: ON" : "Swap Mode";
      }

      clearSwapHighlights();
      firstCell = null;

      const s = document.getElementById("status");
      if (s) s.textContent = swapMode
        ? "Swap Mode ON: click two videos to swap their positions."
        : "";
    }

    function swapTwoCellsDom(a, b) {
      if (!a || !b || a === b) return;
      const parent = a.parentNode;
      if (!parent || parent !== b.parentNode) return;

      // Swap DOM nodes without rebuilding => videos keep playing
      const aNext = a.nextSibling;
      const bNext = b.nextSibling;

      if (aNext === b) {
        parent.insertBefore(b, a);
      } else if (bNext === a) {
        parent.insertBefore(a, b);
      } else {
        parent.insertBefore(a, bNext);
        parent.insertBefore(b, aNext);
      }
    }

    function onCellClick(e) {
      if (!swapMode) return;

      const cell = e.currentTarget;
      if (cell.classList.contains("empty")) return;

      e.preventDefault();
      e.stopPropagation();

      if (!firstCell) {
        firstCell = cell;
        clearSwapHighlights();
        cell.classList.add("swap-pending");
        return;
      }

      if (cell === firstCell) {
        firstCell.classList.remove("swap-pending");
        firstCell = null;
        return;
      }

      swapTwoCellsDom(firstCell, cell);

      firstCell.classList.remove("swap-pending");
      cell.classList.add("swap-highlight");
      setTimeout(() => cell.classList.remove("swap-highlight"), 300);

      firstCell = null;

      requestAnimationFrame(() => resizeGrid());
      saveCurrentLayout();
    }

    if (swapBtn) {
      swapBtn.addEventListener("click", () => setSwapMode(!swapMode));
    }

    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && swapMode) setSwapMode(false);
    });

    /***********************
     * Fullscreen + QR overlay
     ***********************/
    function updateFullscreenQr() {
      const wrapper = document.getElementById("gridWrapper");
      const overlay = document.getElementById("qrCodeOverlay");
      if (!overlay) return;
      const isFS =
        document.fullscreenElement === wrapper ||
        document.webkitFullscreenElement === wrapper;
      const selectedLabel = SOURCES[getSelectedIndex()]?.label || "";
      const shouldShow = isFS && selectedLabel === TELEGRAM_LABEL;
      overlay.classList.toggle("show", !!shouldShow);
    }

    function handleFullscreenChange() {
      const wrapper = document.getElementById("gridWrapper");
      const isFS =
        document.fullscreenElement === wrapper ||
        document.webkitFullscreenElement === wrapper;

      if (!isFS) {
        requestAnimationFrame(() => {
          window.scrollTo({ top: scrollBeforeFullscreen, behavior: "auto" });
        });
      }

      resizeGrid();
      updateFullscreenQr();
    }

    document.addEventListener("fullscreenchange", handleFullscreenChange);
    document.addEventListener("webkitfullscreenchange", handleFullscreenChange);

    /***********************
     * Aspect mode
     ***********************/
    function getAspectMode() {
      const v = localStorage.getItem(ASPECT_MODE_STORE);
      return v === "auto" ? "auto" : "fixed";
    }
    function setAspectMode(v) {
      localStorage.setItem(ASPECT_MODE_STORE, v === "auto" ? "auto" : "fixed");
    }
    function renderAspectBtn() {
      const btn = document.getElementById("aspectModeBtn");
      if (!btn) return;
      const mode = getAspectMode();
      btn.textContent = mode === "auto" ? "Aspect: AUTO-FIT" : "Aspect: 16:9";
      btn.classList.toggle("toggle-on", mode === "auto");
    }

    document.getElementById("aspectModeBtn").addEventListener("click", () => {
      const next = getAspectMode() === "auto" ? "fixed" : "auto";
      setAspectMode(next);
      renderAspectBtn();
      resizeGrid();
    });

    /***********************
     * Controls wiring
     ***********************/
    document.getElementById("searchFillBtn").addEventListener("click", () => doSearchFill(false));
    document.getElementById("randomFillBtn").addEventListener("click", () => doSearchFill(true));

    document.getElementById("reload").addEventListener("click", () => {
      loadSelectedIntoGrid(getSelectedIndex());
      updateFullscreenQr();
    });

    document.getElementById("fullscreenBtn").addEventListener("click", toggleGridFullscreen);

    document.getElementById("overlayToggleBtn").addEventListener("click", () => {
      const next = !getOverlayControlsEnabled();
      setOverlayControlsEnabled(next);
      applyOverlayControlsState();
      document.getElementById("status").textContent =
        next ? "Max Mode ON: click=mute, double-click=grid fullscreen." : "Max Mode OFF: YouTube controls clickable.";
    });

    document.getElementById("resetBtn").addEventListener("click", resetProgress);

    // Save/Clear layout buttons (restored)
    document.getElementById("saveLayoutBtn").addEventListener("click", saveCurrentLayout);
    document.getElementById("clearLayoutBtn").addEventListener("click", () => {
      clearSavedLayout();
      const s = document.getElementById("status");
      if (s) s.textContent = "Saved layout cleared.";
    });

    // Save API key button (your UI had it but your pasted JS didn't wire it)
    document.getElementById("saveKeyBtn").addEventListener("click", () => {
      const input = document.getElementById("ytApiKey");
      const v = (input.value || "").trim();
      if (!v) {
        localStorage.removeItem(KEY_STORE);
        document.getElementById("keyStatus").textContent = "Cleared API key.";
        return;
      }
      localStorage.setItem(KEY_STORE, v);
      input.value = "‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢";
      document.getElementById("keyStatus").textContent = "API key saved locally.";
    });

    window.addEventListener("resize", () => {
      buildSourcesPreview();
      resizeGrid();
      updateFullscreenQr();
    });

    /***********************
     * Fetch items
     ***********************/
    async function fetchItems(url) {
      const res = await fetch(url, { credentials: "omit", cache: "no-store" });
      if (!res.ok) {
        if (url.endsWith("youtube_links.txt")) return [];
        throw new Error(`HTTP ${res.status} ${res.statusText}\n${url}`);
      }

      const text = await res.text();
      if (/ServiceLogin|accounts\.google\.com/i.test(text)) {
        throw new Error("Sheet must be public.");
      }

      const lines = text
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(Boolean);

      const isSheet = url.includes("spreadsheets") || url.includes("googleusercontent.com");
      const values = isSheet
        ? lines.map(l =>
            (l.includes(",") || l.includes("\t"))
              ? l.split(/,|\t/)[0].trim()
              : l
          )
        : lines;

      if (values.length && !parseYouTube(values[0])) values.shift();

      return values
        .map(parseYouTube)
        .filter(Boolean)
        .slice(0, MAX_ITEMS);
    }

    /***********************
     * Telegram incremental updates (NO reload of existing iframes)
     ***********************/
    function prependTelegramItemToGrid(item, settings) {
      const grid = document.getElementById("grid");
      const cols = settings.cols;
      const maxCells = settings.forced ? settings.slots : TELEGRAM_MAX_VIDEOS;

      grid.style.gridTemplateColumns = `repeat(${cols}, minmax(0, 1fr))`;

      if (!grid.firstElementChild) {
        buildTable([item], settings);
        telegramDisplayKeys = [getItemKey(item)];
        ensureYouTubeAPI();
        if (ytApiReady) initPlayers();
        return;
      }

      const newCell = makeCell(item, 0);
      grid.insertBefore(newCell, grid.firstChild);

      while (grid.children.length > maxCells) {
        const last = grid.lastElementChild;
        last?.remove();
      }

      const key = getItemKey(item);
      telegramDisplayKeys = [key, ...telegramDisplayKeys].slice(0, maxCells);

      ensureYouTubeAPI();
      if (ytApiReady) initPlayers();

      requestAnimationFrame(() => {
        resizeGrid();
        updateFullscreenQr();
      });
    }

    async function pollTelegramLinks() {
      const telegramSrc = SOURCES.find(s => s.label === TELEGRAM_LABEL);
      if (!telegramSrc) return;

      try {
        const res = await fetch(telegramSrc.url + "?_=" + Date.now(), {
          cache: "no-store",
          credentials: "omit"
        });
        if (!res.ok) {
          console.warn("Telegram file fetch failed", res.status);
          return;
        }

        const text = await res.text();
        const lines = text
          .split(/\r?\n/)
          .map(l => l.trim())
          .filter(Boolean);

        if (telegramLastLineCount === 0) {
          telegramLastLineCount = lines.length;
          return;
        }

        if (lines.length <= telegramLastLineCount) return;

        // new lines are at the TOP (newest-first file)
        const newCount = lines.length - telegramLastLineCount;
        if (newCount <= 0) return;

        const newLines = lines.slice(0, newCount);
        telegramLastLineCount = lines.length;

        const existing = (cache.get(TELEGRAM_LABEL)?.items || []);
        const newItems = newLines.map(parseYouTube).filter(Boolean);
        if (!newItems.length) return;

        let updated = newItems.concat(existing);
        if (updated.length > TELEGRAM_MAX_VIDEOS * 3) {
          updated = updated.slice(0, TELEGRAM_MAX_VIDEOS * 3);
        }

        cache.set(TELEGRAM_LABEL, { items: updated, counts: itemCounts(updated) });

        const selectedLabel = SOURCES[getSelectedIndex()]?.label;
        if (selectedLabel === TELEGRAM_LABEL) {
          const settings = getGridSettings();

          // prepend oldest-first so newest ends up at very top
          for (let i = newItems.length - 1; i >= 0; i--) {
            prependTelegramItemToGrid(newItems[i], settings);
          }

          const shownCount = document.querySelectorAll("#grid iframe").length;
          document.getElementById("loadedCount").textContent =
            `Loaded embeds: ${shownCount} from Telegram Chat (live)`;
          document.getElementById("status").textContent =
            `Live from Telegram: ${shownCount} video${shownCount === 1 ? "" : "s"} (rolling newest-first)`;
        }

        buildSourcesPreview();
      } catch (e) {
        console.error("Telegram live poll error:", e);
      }
    }

    function startTelegramLive() {
      if (telegramLiveTimer) clearInterval(telegramLiveTimer);
      const telegramSrc = SOURCES.find(s => s.label === TELEGRAM_LABEL);
      if (!telegramSrc) return;
      telegramLastLineCount = 0;
      telegramLiveTimer = setInterval(pollTelegramLinks, TELEGRAM_POLL_INTERVAL);
    }

    /***********************
     * Boot
     ***********************/
    async function init() {
      applyOverlayControlsState();

      const k = localStorage.getItem(KEY_STORE) || "";
      const keyInput = document.getElementById("ytApiKey");
      keyInput.value = k ? "‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" : "";
      document.getElementById("keyStatus").textContent =
        k ? "API key saved locally." : "No API key saved yet.";

      try {
        await loadAllSources();
      } catch (e) {
        const error = document.getElementById("error");
        error.textContent = e.message || String(e);
        error.style.display = "block";
      }

      const selected = getSelectedIndex();
      setSelectedIndex(selected);
      await loadSelectedIntoGrid(selected);

      renderAspectBtn();
      requestAnimationFrame(() => {
        resizeGrid();
        updateFullscreenQr();
      });

      startTelegramLive();
    }

    init();
  </script>
</body>
</html>
